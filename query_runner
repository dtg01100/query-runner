#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"
DRIVERS_DIR="$SCRIPT_DIR/drivers"
CACHE_DIR="$HOME/.query_runner/cache"

# Java binaries
JAVA_BIN=""
JAVAC_BIN=""

# Default debug flag from environment variable - CLI can override
QUERY_RUNNER_DEBUG="${QUERY_RUNNER_DEBUG:-0}"

# Cache management functions
init_cache() {
    [[ -d "$CACHE_DIR" ]] || mkdir -p "$CACHE_DIR"
}

get_source_hash() {
    # Hash of the query_runner script itself
    md5sum "$0" | cut -d' ' -f1
}

get_drivers_hash() {
    # Hash of all JAR files in drivers directory
    local drivers_hash=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_hash=$(find "$DRIVERS_DIR" -name "*.jar" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
    fi
    echo "$drivers_hash"
}

get_cache_key() {
    local source_hash
    local drivers_hash
    source_hash=$(get_source_hash)
    drivers_hash=$(get_drivers_hash)
    echo "${source_hash}_${drivers_hash}"
}

get_cache_dir_for_key() {
    local cache_key="$1"
    echo "$CACHE_DIR/$cache_key"
}

# Debug helper: echo messages only when DEBUG is enabled
debug() {
    local debug_val="${DEBUG:-$QUERY_RUNNER_DEBUG}"
    if [[ "$debug_val" != "0" && "$debug_val" != "false" ]]; then
        echo "DEBUG: $*" >&2
    fi
}

# Normalize / harden file path handling for query file path
# - trims whitespace and CRLF characters
# - expands leading ~ to $HOME
# - canonicalizes path using realpath/readlink or fallback
# - rejects strings containing control characters (NUL/newline/tab/carriage return) as unsafe
normalize_query_file_path() {
    local path="$1"
    # Reject CR and NUL characters explicitly, then trim whitespace
    # Detect NUL bytes if `od` is available
    if command -v od >/dev/null 2>&1; then
        if printf '%s' "$path" | od -An -t x1 -v | grep -q -E '(^| )00($| )'; then
            return 1
        fi
    else
        # Fallback: detect control characters including carriage return via awk
        if printf '%s' "$path" | awk '/[[:cntrl:]]/ { exit 1 }'; then
            :
        else
            return 1
        fi
    fi
    # Reject any carriage returns or tabs or newline characters explicitly
    case "$path" in
        *$'\r'*|*$'\n'*|*$'\t'*)
            return 1
            ;;
    esac
    # Trim leading/trailing whitespace (spaces and tabs)
    path=$(printf '%s' "$path" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

    # Reject paths containing newline/tab (weird terminals)
    case "$path" in
        *$'\n'*|*$'\t'*)
            return 1
            ;;
    esac

    # Expand ~ at beginning
    if [[ "$path" == ~* ]]; then
        # expand ~ and ~user only for simple forms
        if [[ "$path" =~ ^~[a-zA-Z0-9_\-]+(/.*)?$ ]]; then
            # shell will expand ~user only when not quoted, so fallback to path as-is (no expansion)
            true
        else
            path="${path/#\~/$HOME}"
        fi
    fi

    # Fast path: '-' means stdin
    if [[ "$path" == "-" ]]; then
        printf '%s' "-"
        return 0
    fi

    # If path exists, canonicalize; otherwise return path as provided
    if [[ -e "$path" ]]; then
        if command -v realpath >/dev/null 2>&1; then
            local canonical
            canonical=$(realpath -m -- "$path" 2>/dev/null || true)
            if [[ -n "$canonical" ]]; then
                printf '%s' "$canonical"
                return 0
            fi
        fi
        if command -v readlink >/dev/null 2>&1; then
            local canonical2
            canonical2=$(readlink -f -- "$path" 2>/dev/null || true)
            if [[ -n "$canonical2" ]]; then
                printf '%s' "$canonical2"
                return 0
            fi
        fi
        # Fallback to absolute via cd
        local dir base abs
        dir=$(dirname -- "$path")
        base=$(basename -- "$path")
        if cd -- "$dir" 2>/dev/null; then
            abs="$PWD/$base"
            printf '%s' "$abs"
            return 0
        fi
    fi

    # If not found or canonicalization fails, return the trimmed path (may be relative)
    printf '%s' "$path"
    return 0
}

is_cache_valid() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")

    [[ -d "$cache_path" ]] || return 1
    [[ -f "$cache_path/QueryRunner.class" ]] || return 1
    [[ -f "$cache_path/metadata.json" ]] || return 1

    # Check if cache is not too old (24 hours)
    local cache_age
    cache_age=$(find "$cache_path" -maxdepth 1 -type f -mtime +1 | wc -l)
    [[ $cache_age -eq 0 ]] || return 1

    return 0
}

save_to_cache() {
    local cache_key="$1"
    local temp_dir="$2"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")

    # Create cache directory
    mkdir -p "$cache_path"

    # Copy compiled class file
    cp "$temp_dir/QueryRunner.class" "$cache_path/"

    # Save metadata
    cat > "$cache_path/metadata.json" << 'EOF'
{
    "source_hash": "$(get_source_hash)",
    "drivers_hash": "$(get_drivers_hash)",
    "created_at": "$(date -Iseconds)",
    "query_runner_version": "1.0"
}
EOF
}

load_from_cache() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")
    echo "$cache_path/QueryRunner.class"
}

cleanup_old_cache() {
    # Remove cache directories older than 7 days
    find "$CACHE_DIR" -maxdepth 1 -type d -mtime +7 -exec rm -rf {} \; 2>/dev/null || true
}

check_java_availability() {
    if command -v java >/dev/null 2>&1 && command -v javac >/dev/null 2>&1; then
        JAVA_BIN=$(command -v java)
        JAVAC_BIN=$(command -v javac)
        return 0
    fi
    return 1
}

download_standalone_jdk() {
    local java_version="21"
    local java_url="https://api.adoptium.net/v3/binary/latest/${java_version}/ga/linux/x64/jdk/hotspot/normal/adoptium"
    local java_archive="$CACHE_DIR/jdk.tar.gz"
    local java_dir="$CACHE_DIR/jdk"

    if [[ ! -d "$java_dir" ]]; then
        echo "Java is not found on your system." >&2
        read -p "Do you want to download a standalone JDK? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Java is required to run this script. Aborting." >&2
            exit 1
        fi

        echo "Downloading standalone JDK..." >&2
        if ! curl -L -o "$java_archive" "$java_url" 2>/dev/null; then
            echo "Error: Failed to download JDK from $java_url" >&2
            exit 1
        fi
        mkdir -p "$java_dir"
        if ! tar -xzf "$java_archive" -C "$java_dir" --strip-components=1 2>/dev/null; then
            echo "Error: Failed to extract JDK archive" >&2
            rm -f "$java_archive"
            exit 1
        fi
        rm -f "$java_archive"
    fi

    JAVA_BIN="$java_dir/bin/java"
    JAVAC_BIN="$java_dir/bin/javac"

    # Verify the downloaded Java works
    if ! "$JAVA_BIN" -version >/dev/null 2>&1 || ! "$JAVAC_BIN" -version >/dev/null 2>&1; then
        echo "Error: Downloaded JDK is not functional" >&2
        rm -rf "$java_dir"
        exit 1
    fi
}

get_classpath_cache_key() {
    # Generate cache key based on drivers directory contents and timestamps
    local drivers_info=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_info=$(find "$DRIVERS_DIR" -name "*.jar" -type f -printf "%p|%T@\n" 2>/dev/null | sort | md5sum | cut -d' ' -f1)
    fi
    echo "classpath_${drivers_info}"
}

get_cached_classpath() {
    local cache_key="$1"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"

    if [[ -f "$cache_file" ]]; then
        # Check if cache is still valid (drivers haven't changed)
        local current_key
        current_key=$(get_classpath_cache_key)
        if [[ "$cache_key" == "$current_key" ]]; then
            debug "Using cached classpath file: $cache_file"
            cat "$cache_file"
            return 0
        fi
    fi

    return 1
}

save_classpath_cache() {
    local cache_key="$1"
    local classpath="$2"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"
    echo "$classpath" > "$cache_file"
}

build_classpath() {
    local jar_file="$1"
    local cache_key
    cache_key=$(get_classpath_cache_key)

    # Try to get from cache first
    local cached_classpath
    if cached_classpath=$(get_cached_classpath "$cache_key"); then
        debug "Using cached classpath: $cached_classpath"
        echo "$cached_classpath:$jar_file"
        return 0
    fi

    # Build classpath from scratch with lazy loading
    local classpath="$jar_file"
    local db_type
    db_type=$(detect_database_type)

    if [[ -d "$DRIVERS_DIR" ]]; then
        case "$db_type" in
            "mysql")
                for jar in "$DRIVERS_DIR"/*mysql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "postgresql")
                for jar in "$DRIVERS_DIR"/*postgresql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "oracle")
                for jar in "$DRIVERS_DIR"/*oracle*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlserver")
                for jar in "$DRIVERS_DIR"/*sqlserver*.jar "$DRIVERS_DIR"/*mssql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "db2")
                for jar in "$DRIVERS_DIR"/*db2*.jar "$DRIVERS_DIR"/*jt400*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "h2")
                for jar in "$DRIVERS_DIR"/*h2*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlite")
                for jar in "$DRIVERS_DIR"/*sqlite*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            *)
                # Fallback: include all JARs
                for jar in "$DRIVERS_DIR"/*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
        esac

        # Always include SLF4J dependencies if present
        for jar in "$DRIVERS_DIR"/slf4j*.jar; do
            [[ -f "$jar" ]] && classpath="$classpath:$jar"
        done
    fi

    # Save to cache
    save_classpath_cache "$cache_key" "$classpath"

    echo "$classpath"
}

get_precompiled_class() {
    # Check for pre-compiled QueryRunner.class in script directory
    local precompiled="$SCRIPT_DIR/QueryRunner.class"
    if [[ -f "$precompiled" ]]; then
        # Check if it's compatible with current script
        local script_hash
        script_hash=$(get_source_hash)
        local precompiled_hash_file="$SCRIPT_DIR/.query_runner_hash"

        if [[ -f "$precompiled_hash_file" ]]; then
            local stored_hash
            stored_hash=$(cat "$precompiled_hash_file")
            if [[ "$script_hash" == "$stored_hash" ]]; then
                echo "$precompiled"
                return 0
            fi
        fi
    fi

    return 1
}

save_precompiled_hash() {
    local script_hash
    script_hash=$(get_source_hash)
    echo "$script_hash" > "$SCRIPT_DIR/.query_runner_hash"
}

usage() {
    cat << 'EOF'
Usage: $(basename "$0") [OPTIONS] [QUERY_FILE]

Execute read-only SQL queries using JDBC with autoconfiguration.

Arguments:
    QUERY_FILE    Optional path to file containing SQL query.
                  If not provided, reads query from stdin.

Options:
    -f, --format FORMAT     Output format: text, csv, json, pretty
    -t, --type TYPE         Database type: mysql, postgresql, oracle, sqlserver,
                           db2, h2, sqlite (auto-detect if not specified)
    -h, --host HOST         Database host (overrides .env)
    -p, --port PORT         Database port (overrides .env)
    -d, --database DATABASE Database name (overrides .env)
    -u, --user USER         Database user (overrides .env)
    -P, --password PASSWORD Database password (overrides .env)
    -e, --env-file FILE     Custom environment file (default: .env)
    --drivers-dir DIR       JDBC drivers directory (default: ./drivers)
    --list-drivers          List available database drivers and exit
    --test-connection       Test database connection and exit
    -v, --verbose           Enable verbose debug output (same as QUERY_RUNNER_DEBUG=1)
    --debug                 Alias for --verbose
    --download-driver TYPE  Download JDBC driver for TYPE (mysql, postgresql, h2, sqlite, sqlserver)
    --allow-union-tables TABLES  Comma-separated list of tables allowed in UNION queries
    --retry-max-attempts N     Maximum number of connection retry attempts (default: 1)
    --retry-backoff-factor F   Exponential backoff factor for retries (default: 2.0)
    --retry-initial-delay D    Initial delay in milliseconds before first retry (default: 1000)
    -h, --help              Show this help message
    --                      End of options; next argument is interpreted as the query file (even if it starts with '-').

Examples:
    echo "SELECT * FROM users LIMIT 10" | $(basename "$0")
    $(basename "$0") -t mysql query.sql
    $(basename "$0") -f json --host localhost --port 5432 -t postgresql query.sql
    $(basename "$0") --test-connection

Environment:
    Uses .env file for database connection settings.
    Autoconfigures based on DB_TYPE.
    Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite
EOF
    exit 1
}

check_union_safety() {
    local query="$1"
    local normalized_query
    normalized_query=$(echo "$query" | tr '[:upper:]' '[:lower:]' | sed 's/--.*$//' | sed 's/\s\+/ /g' | xargs)

    # Allow UNION in safe contexts:
    # 1. WITH clauses (CTEs) - safe self-contained operations
    # 2. UNION ALL within same table - safe for data deduplication
    # 3. Explicitly allowed by user flag

    # Check for UNION in CTE context (safe)
    if [[ "$normalized_query" =~ with[[:space:]]+.*[[:space:]]+union[[:space:]]+(all[[:space:]]+)?select ]]; then
        return 0  # Allow UNION and UNION ALL in CTEs
    fi

    # Check for UNION ALL (safer than UNION DISTINCT)
    if [[ "$normalized_query" =~ union[[:space:]]+all[[:space:]]+select ]]; then
        return 0  # Allow UNION ALL (less risky)
    fi

    # Check for UNION between same table (safe)
    if [[ "$normalized_query" =~ union[[:space:]]+select[[:space:]]+from[[:space:]]+([a-z_][a-z0-9_]*)[[:space:]]+where[[:space:]]+.*[[:space:]]+union[[:space:]]+select[[:space:]]+from[[:space:]]+\1[[:space:]] ]]; then
        return 0  # Allow UNION within same table
    fi

    # Check for explicit whitelist flag
    if [[ -n "${ALLOW_UNION_TABLES:-}" ]]; then
        local allowed_tables
        IFS=',' read -ra allowed_tables <<< "$ALLOW_UNION_TABLES"
        for table in "${allowed_tables[@]}"; do
            table=$(echo "$table" | xargs)  # trim whitespace
            if [[ "$normalized_query" =~ (union.*from.*$table|from.*$table.*union) ]]; then
                return 0  # Allow UNION for whitelisted tables
            fi
        done
    fi

    # Default: Block risky UNION operations
    echo "Error: UNION queries combining data from multiple sources are not allowed by default." >&2
    echo "For safe UNION operations, use:" >&2
    echo "  1. UNION ALL with the same table" >&2
    echo "  2. UNION in WITH clauses (CTEs)" >&2
    echo "  3. --allow-union-tables=table1,table2 flag for trusted tables" >&2
    exit 1
}

check_read_only() {
    local query="$1"
    local normalized_query
    # Normalize query: lowercase, remove comments, collapse whitespace
    normalized_query=$(echo "$query" | perl -ne 'print lc' | perl -pe 's/--.*?$//g; s/\/\*.*?\*\///g; s/\s+/ /g;' | xargs)

    # Check for dangerous patterns anywhere in the query
    local dangerous_patterns=(
        "insert "
        "update "
        "delete "
        "drop "
        "create "
        "alter "
        "truncate "
        "exec "
        "execute "
        "grant "
        "revoke "
        "commit "
        "rollback "
        "union "  # Will be validated with smart detection
        "load "   # LOAD DATA INFILE
        "copy "   # COPY command in PostgreSQL
        "backup " # BACKUP DATABASE
        "restore " # RESTORE DATABASE
    )

    for pattern in "${dangerous_patterns[@]}"; do
        if [[ "$normalized_query" =~ [[:space:]]$pattern ]]; then
            # Special handling for UNION - use smart detection
            if [[ "$pattern" == "union " ]]; then
                check_union_safety "$query"
            else
                echo "Error: Only read-only queries are allowed. Detected potentially dangerous pattern: $pattern" >&2
                exit 1
            fi
        fi
    done

    # Check for multiple statements (semicolon separation)
    if [[ "$normalized_query" == *";"* ]]; then
echo "Error: Multiple SQL statements are not allowed" >&2
        exit 1
    fi

    # Query must start with a read-only operation
    if [[ ! "$normalized_query" =~ ^[[:space:]]*(select|with|show|describe|explain|pragma)[[:space:]] ]]; then
echo "Error: Query must start with a read-only operation (SELECT, WITH, SHOW, DESCRIBE, EXPLAIN, PRAGMA)" >&2
        exit 1
    fi
}

detect_database_type() {
    local db_type="${DB_TYPE:-}"

    if [[ -n "$db_type" ]]; then
echo "$db_type"
        return 0
    fi

    # Try to detect from JDBC_URL if available
    if [[ -n "${JDBC_URL:-}" ]]; then
        case "$JDBC_URL" in
            *mysql*) echo "mysql"; return 0 ;;
            *postgresql*) echo "postgresql"; return 0 ;;
            *oracle*) echo "oracle"; return 0 ;;
            *sqlserver*) echo "sqlserver"; return 0 ;;
            *db2*) echo "db2"; return 0 ;;
            *h2*) echo "h2"; return 0 ;;
            *sqlite*) echo "sqlite"; return 0 ;;
        esac
    fi

    # Try to detect from available drivers
    if [[ -d "$DRIVERS_DIR" ]]; then
        if ls "$DRIVERS_DIR"/*mysql* 1> /dev/null 2>&1; then echo "mysql"; return 0; fi
        if ls "$DRIVERS_DIR"/*postgresql* 1> /dev/null 2>&1; then echo "postgresql"; return 0; fi
        if ls "$DRIVERS_DIR"/*oracle* 1> /dev/null 2>&1; then echo "oracle"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlserver* 1> /dev/null 2>&1; then echo "sqlserver"; return 0; fi
        if ls "$DRIVERS_DIR"/*db2* 1> /dev/null 2>&1; then echo "db2"; return 0; fi
        if ls "$DRIVERS_DIR"/*h2* 1> /dev/null 2>&1; then echo "h2"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlite* 1> /dev/null 2>&1; then echo "sqlite"; return 0; fi
    fi

    return 1
}

configure_database() {
    local db_type="$1"

    case "$db_type" in
        mysql)
            DB_PORT="${DB_PORT:-3306}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.mysql.cj.jdbc.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mysql-connector-java*.jar}"
            ;;
        postgresql)
            DB_PORT="${DB_PORT:-5432}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.postgresql.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-postgresql*.jar}"
            ;;
        oracle)
            DB_PORT="${DB_PORT:-1521}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-oracle.jdbc.OracleDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:oracle:thin:@${DB_HOST}:${DB_PORT}:${DB_DATABASE}?connectTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-ojdbc*.jar}"
            ;;
        sqlserver)
            DB_PORT="${DB_PORT:-1433}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.microsoft.sqlserver.jdbc.SQLServerDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:sqlserver://${DB_HOST}:${DB_PORT};databaseName=${DB_DATABASE};loginTimeout=${timeout};socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mssql-jdbc*.jar}"
            ;;
        db2)
            DB_PORT="${DB_PORT:-50000}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.ibm.db2.jcc.DB2Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:db2://${DB_HOST}:${DB_PORT}/${DB_DATABASE}:clientProgramName=${timeout};"
            fi
            DRIVER_JAR="${DRIVER_JAR:-db2jcc*.jar jt400*.jar}"
            ;;
        h2)
            DB_PORT="${DB_PORT:-9092}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.h2.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:h2:tcp://${DB_HOST}:${DB_PORT}/${DB_DATABASE};loginTimeout=${timeout}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-h2*.jar}"
            ;;
        sqlite)
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.sqlite.JDBC}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                JDBC_URL="jdbc:sqlite:${DB_DATABASE}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-sqlite-jdbc*.jar}"
            ;;
        *)
            echo "Error: Unsupported database type: $db_type" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
            ;;
    esac
}

find_driver_jar() {
    local driver_pattern="$1"
    local jar_files=()

    # Search in drivers directory
    if [[ -d "$DRIVERS_DIR" ]]; then
        for pattern in $driver_pattern; do
            while IFS= read -r -d '' jar; do
                jar_files+=("$jar")
            done < <(find "$DRIVERS_DIR" -name "$pattern" -type f -print0 2>/dev/null)
        done
    fi

    # Search in script directory
    while IFS= read -r -d '' jar; do
        jar_files+=("$jar")
    done < <(find "$SCRIPT_DIR" -name "*.jar" -type f -print0 2>/dev/null)

    if [[ ${#jar_files[@]} -eq 0 ]]; then
echo "Error: No JDBC driver found matching pattern: $driver_pattern" >&2
echo "Please place the appropriate JDBC driver JAR in $DRIVERS_DIR or $SCRIPT_DIR" >&2
        exit 1
    fi

    # Return the first match
    echo "${jar_files[0]}"
}

list_drivers() {
    echo "Available database drivers:"
    echo "=========================="

    local found_drivers=()

    if [[ -d "$DRIVERS_DIR" ]]; then
        while IFS= read -r -d '' jar; do
            local basename
            basename=$(basename "$jar")
            case "$basename" in
                *mysql*) found_drivers+=("MySQL: $basename") ;;
                *postgresql*) found_drivers+=("PostgreSQL: $basename") ;;
                *oracle*) found_drivers+=("Oracle: $basename") ;;
                *sqlserver*|*mssql*) found_drivers+=("SQL Server: $basename") ;;
                *db2*|*jt400*) found_drivers+=("DB2/AS400: $basename") ;;
                *h2*) found_drivers+=("H2: $basename") ;;
                *sqlite*) found_drivers+=("SQLite: $basename") ;;
                *) found_drivers+=("Unknown: $basename") ;;
            esac
        done < <(find "$DRIVERS_DIR" -name "*.jar" -type f -print0 2>/dev/null)
    fi

    if [[ ${#found_drivers[@]} -eq 0 ]]; then
echo "No JDBC drivers found in $DRIVERS_DIR"
echo "Download drivers and place them in the drivers directory:"
echo "- MySQL: https://dev.mysql.com/downloads/connector/j/"
echo "- PostgreSQL: https://jdbc.postgresql.org/download/"
echo "- Oracle: https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html"
echo "- SQL Server: https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server"
echo "- DB2: https://www.ibm.com/support/pages/node/6331129"
echo "- H2: https://www.h2database.com/html/download.html"
echo "- SQLite: https://github.com/xerial/sqlite-jdbc/releases"
    else
        printf '%s\n' "${found_drivers[@]}"
    fi
}

download_driver() {
    local type="$1"
    local url=""
    local filename=""
    case "$type" in
        mysql)
            url="https://repo1.maven.org/maven2/com/mysql/mysql-connector-j/8.0.33/mysql-connector-j-8.0.33.jar"
            filename="mysql-connector-j-8.0.33.jar"
            ;;
        postgresql)
            url="https://repo1.maven.org/maven2/org/postgresql/postgresql/42.6.0/postgresql-42.6.0.jar"
            filename="postgresql-42.6.0.jar"
            ;;
        h2)
            url="https://repo1.maven.org/maven2/com/h2database/h2/2.1.214/h2-2.1.214.jar"
            filename="h2-2.1.214.jar"
            ;;
        sqlite)
            url="https://repo1.maven.org/maven2/org/xerial/sqlite-jdbc/3.42.0.0/sqlite-jdbc-3.42.0.0.jar"
            filename="sqlite-jdbc-3.42.0.0.jar"
            ;;
        sqlserver)
            url="https://repo1.maven.org/maven2/com/microsoft/sqlserver/mssql-jdbc/12.4.1.jre11/mssql-jdbc-12.4.1.jre11.jar"
            filename="mssql-jdbc-12.4.1.jre11.jar"
            ;;
        *)
            echo "Error: Unsupported driver type: $type" >&2
            exit 1
            ;;
    esac
    mkdir -p "$DRIVERS_DIR"
    local dest="$DRIVERS_DIR/$filename"
    if [[ -f "$dest" ]]; then
        echo "Driver already exists: $dest" >&2
        return 0
    fi
    echo "Downloading $type driver from $url..." >&2
    if ! curl -L -o "$dest" "$url"; then
        echo "Error: Failed to download $url" >&2
        exit 1
    fi
    echo "Downloaded $type driver to $dest" >&2
}

test_connection() {
    local test_query="SELECT 1"
    execute_query "$test_query" "text" > /dev/null
    echo "Connection successful!" >&2
}

load_env() {
    if [[ ! -f "$ENV_FILE" ]]; then
echo "Warning: .env file not found at $ENV_FILE" >&2
echo "You can specify connection details via command line options" >&2
    else
        set -a
        # shellcheck source=/dev/null
        source "$ENV_FILE"
        set +a
    fi

    # Override with command line arguments if provided
    DB_HOST="${CLI_HOST:-${DB_HOST:-localhost}}"
    DB_PORT="${CLI_PORT:-${DB_PORT:-}}"
    DB_DATABASE="${CLI_DATABASE:-${DB_DATABASE:-}}"
    DB_USER="${CLI_USER:-${DB_USER:-}}"
    DB_PASSWORD="${CLI_PASSWORD:-${DB_PASSWORD:-}}"

# Auto-detect or use specified database type
    local db_type
    if [[ -n "${CLI_TYPE:-}" ]]; then
        db_type="$CLI_TYPE"
    else
        if ! db_type=$(detect_database_type); then
            echo "Error: Could not auto-detect database type" >&2
            echo "Please specify DB_TYPE in .env or use -t option" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
        fi
    fi

    debug "Using database type: $db_type"
    configure_database "$db_type"

    # Find the appropriate driver JAR
    JAR_FILE=$(find_driver_jar "$DRIVER_JAR")
    debug "Using driver: $(basename "$JAR_FILE")"

    # Validate required variables
    if [[ "$db_type" != "sqlite" ]]; then
        required_vars=("DB_HOST" "DB_USER" "DB_PASSWORD")
        for var in "${required_vars[@]}"; do
            if [[ -z "${!var:-}" ]]; then
                echo "Error: Required environment variable $var is not set" >&2
                exit 1
            fi
        done
    fi

    if [[ -z "${DB_DATABASE:-}" && "$db_type" != "sqlite" ]]; then
echo "Error: Database name is required" >&2
        exit 1
    fi
}

execute_query() {
    local query="$1"
    local format="$2"
    local temp_dir
    temp_dir=$(mktemp -d)
    trap 'rm -rf "${temp_dir:-}"' EXIT

    local temp_java_file cache_key cached_class_file

    check_read_only "$query"

    # Check for pre-compiled class first
    local precompiled_class
    local use_precompiled=false
    local compilation_dir

    if precompiled_class=$(get_precompiled_class); then
        compilation_dir=$(dirname "$precompiled_class")
        use_precompiled=true
        debug "Using precompiled class in $compilation_dir"
    else
        # Initialize cache and check for valid cached compilation
        init_cache
        cleanup_old_cache
        cache_key=$(get_cache_key)

        if is_cache_valid "$cache_key"; then
            cached_class_file=$(load_from_cache "$cache_key")
            compilation_dir=$(dirname "$cached_class_file")
            debug "Using cached compiled class in $compilation_dir"
        else
            # Need to compile
            compilation_dir="$temp_dir"
            temp_java_file="$compilation_dir/QueryRunner.java"

cat > "$temp_java_file" << 'EOF'
import java.sql.*;
import java.util.*;
import java.util.regex.*;

public class QueryRunner {

    private static boolean isDebug() {
        String v = System.getenv("QUERY_RUNNER_DEBUG");
        return v != null && (v.equals("1") || v.equalsIgnoreCase("true"));
    }

    private static void debug(String msg) {
        if (isDebug()) System.err.println("DEBUG: " + msg);
    }

    private static String maskJdbcUrl(String url) {
        if (url == null) return null;
        // Mask password= param in JDBC URL if present
        try {
            return url.replaceAll("(?i)(password=)([^&;]+)", "$1******");
        } catch (Exception e) {
            return url;
        }
    }

    public static void main(String[] args) {
        String query = "";
        Scanner scanner = new Scanner(System.in);
        if (scanner.hasNextLine()) {
            query = scanner.useDelimiter("\\A").next();
        }
        String url = System.getenv("JDBC_URL");
        String driver = System.getenv("JDBC_DRIVER_CLASS");
        String user = System.getenv("DB_USER");
        String password = System.getenv("DB_PASSWORD");
        String format = System.getenv("OUTPUT_FORMAT");
        if (format == null) format = "text";
        debug("JDBC driver class: " + driver);
        debug("JDBC URL: " + maskJdbcUrl(url));
        debug("DB user: " + (user == null ? "(none)" : user));
        try {
            Class.forName(driver);
        } catch (ClassNotFoundException e) {
            System.err.println("Error: JDBC driver not found: " + e.getMessage());
            System.exit(1);
        }

        try (Connection conn = DriverManager.getConnection(url, user, password);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {

            ResultSetMetaData meta = rs.getMetaData();
            int columnCount = meta.getColumnCount();
            List<String> columnNames = new ArrayList<>();
            for (int i = 1; i <= columnCount; i++) {
                columnNames.add(meta.getColumnName(i));
            }

            switch (format) {
                case "pretty":
                    // For pretty format, load all rows to calculate widths
                    List<Map<String, Object>> rows = new ArrayList<>();
                    while (rs.next()) {
                        Map<String, Object> row = new HashMap<>();
                        for (int i = 1; i <= columnCount; i++) {
                            row.put(columnNames.get(i-1), rs.getObject(i));
                        }
                        rows.add(row);
                    }
                    outputPretty(columnNames, rows);
                    break;
                case "json":
                    outputJsonStream(columnNames, rs);
                    break;
                case "csv":
                    outputCsvStream(columnNames, rs);
                    break;
                case "text":
                default:
                    outputTextStream(columnNames, rs);
                    break;
            }
        } catch (SQLException e) {
            System.err.println("SQL Error: " + e.getMessage());
            System.err.println("SQL State: " + e.getSQLState());
            System.err.println("Error Code: " + e.getErrorCode());
            if (isDebug()) {
                e.printStackTrace(System.err);
            }
            System.exit(1);
        }
    }

    private static String escapeJson(String str) {
        if (str == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            switch (c) {
                case '\\':
                case '"':
                    sb.append('\\').append(c);
                    break;
                case '\b':
                    sb.append("\\b");
                    break;
                case '\t':
                    sb.append("\\t");
                    break;
                case '\n':
                    sb.append("\\n");
                    break;
                case '\f':
                    sb.append("\\f");
                    break;
                case '\r':
                    sb.append("\\r");
                    break;
                default:
                    if (c < ' ') {
                        String t = "000" + Integer.toHexString(c);
                        sb.append("\\u").append(t.substring(t.length() - 4));
                    } else {
                        sb.append(c);
                    }
            }
        }
        return sb.toString();
    }

    private static String repeatString(String str, int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {
            sb.append(str);
        }
        return sb.toString();
    }

    private static void outputJsonStream(List<String> columnNames, ResultSet rs) throws SQLException {
        System.out.print("[");
        boolean first = true;
        while (rs.next()) {
            if (!first) System.out.print(",");
            first = false;
            System.out.print("{");
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                System.out.print("\"" + escapeJson(columnNames.get(i)) + "\":");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("null");
                } else if (value instanceof Number || value instanceof Boolean) {
                    System.out.print(value.toString());
                } else {
                    System.out.print("\"" + escapeJson(value.toString()) + "\"");
                }
            }
            System.out.print("}");
        }
        System.out.println("]");
    }

    private static void outputCsvStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print(",");
            System.out.print("\"" + columnNames.get(i).replace("\"", "\"\"") + "\"");
        }
        System.out.println();
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("");
                } else {
                    String strValue = value.toString();
                    System.out.print("\"" + strValue.replace("\"", "\"\"") + "\"");
                }
            }
            System.out.println();
        }
    }



    private static void outputTextStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print("\t");
            System.out.print(columnNames.get(i));
        }
        System.out.println();
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print("\t");
                Object value = rs.getObject(i + 1);
                System.out.print(value != null ? value.toString() : "NULL");
            }
            System.out.println();
        }
    }

    private static void outputPretty(List<String> columnNames, List<Map<String, Object>> rows) {
        int[] maxWidths = new int[columnNames.size()];
        for (int i = 0; i < columnNames.size(); i++) {
            maxWidths[i] = columnNames.get(i).length();
        }
        for (Map<String, Object> row : rows) {
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                maxWidths[i] = Math.max(maxWidths[i], strValue.length());
            }
        }
        String separator = "+";
        for (int width : maxWidths) {
            separator += repeatString("-", width + 2) + "+";
        }
        System.out.println(separator);
        System.out.print("|");
        for (int i = 0; i < columnNames.size(); i++) {
            System.out.print(" " + String.format("%-" + maxWidths[i] + "s", columnNames.get(i)) + " |");
        }
        System.out.println();
        System.out.println(separator);
        for (Map<String, Object> row : rows) {
            System.out.print("|");
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                System.out.print(" " + String.format("%-" + maxWidths[i] + "s", strValue) + " |");
            }
            System.out.println();
        }
        System.out.println(separator);
    }
}
EOF

    debug "Compiling temporary Java file: $temp_java_file"
    if ! javac_output=$("$JAVAC_BIN" "$temp_java_file" 2>&1); then
            echo "Error: Failed to compile Java code" >&2
            echo "Compilation error details:" >&2
            echo "$javac_output" >&2
            exit 1
        fi
        # Save to cache for future use
        save_to_cache "$cache_key" "$compilation_dir"
        debug "Compiled and saved class to cache at $compilation_dir"
        fi
    fi
    local classpath
    classpath=$(build_classpath "$JAR_FILE")
    export OUTPUT_FORMAT="$format" JDBC_URL JDBC_DRIVER_CLASS DB_USER DB_PASSWORD
    # Pass DEBUG to Java process as QUERY_RUNNER_DEBUG env var so the Java runner can also print debug info
    export QUERY_RUNNER_DEBUG="${DEBUG:-${QUERY_RUNNER_DEBUG:-0}}"
    echo -n "$query" | "$JAVA_BIN" --enable-native-access=ALL-UNNAMED -cp "$classpath:$compilation_dir" QueryRunner
    debug "Running java: $JAVA_BIN -cp $classpath:$compilation_dir QueryRunner"
}

# Check for Java availability
if ! check_java_availability; then
    download_standalone_jdk
fi

# Main script logic
CLI_HOST=""
CLI_PORT=""
CLI_DATABASE=""
CLI_USER=""
CLI_PASSWORD=""
CLI_TYPE=""
CLI_FORMAT="text"
CLI_ENV_FILE=""
ALLOW_UNION_TABLES=""
RETRY_MAX_ATTEMPTS=1
RETRY_BACKOFF_FACTOR=2.0
RETRY_INITIAL_DELAY=1000
DOWNLOAD_DRIVER=""
QUERY_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --)
            # End of options; treat the next argument as the query file (even if it starts with -)
            shift
            if [[ $# -ge 1 ]]; then
                QUERY_FILE="$1"
                shift
            fi
            break
            ;;
        -f|--format)
            CLI_FORMAT="$2"
            shift 2
            ;;
        -t|--type)
            CLI_TYPE="$2"
            shift 2
            ;;
        -h|--host)
            CLI_HOST="$2"
            shift 2
            ;;
        -p|--port)
            CLI_PORT="$2"
            shift 2
            ;;
        -d|--database)
            CLI_DATABASE="$2"
            shift 2
            ;;
        -u|--user)
            CLI_USER="$2"
            shift 2
            ;;
        -P|--password)
            CLI_PASSWORD="$2"
            shift 2
            ;;
        -e|--env-file)
            CLI_ENV_FILE="$2"
            shift 2
            ;;
        --drivers-dir)
            DRIVERS_DIR="$2"
            shift 2
            ;;
        --list-drivers)
            list_drivers
            exit 0
            ;;
        --test-connection)
            load_env
            test_connection
            exit 0
            ;;
        --download-driver)
            DOWNLOAD_DRIVER="$2"
            shift 2
            ;;
        --allow-union-tables)
            ALLOW_UNION_TABLES="$2"
            shift 2
            ;;
        --retry-max-attempts)
            RETRY_MAX_ATTEMPTS="$2"
            shift 2
            ;;
        --retry-backoff-factor)
            RETRY_BACKOFF_FACTOR="$2"
            shift 2
            ;;
        --retry-initial-delay)
            RETRY_INITIAL_DELAY="$2"
            shift 2
            ;;
        -v|--verbose)
            CLI_VERBOSE=1
            DEBUG=1
            shift
            ;;
        --debug)
            CLI_DEBUG=1
            DEBUG=1
            shift
            ;;
        -h|--help)
            usage
            ;;
        -*)
            echo "Unknown option: $1" >&2
            usage
            ;;
        *)
            QUERY_FILE="$1"
            shift
            ;;
    esac
done

if [[ -n "$DOWNLOAD_DRIVER" ]]; then
    download_driver "$DOWNLOAD_DRIVER"
    exit 0
fi

# Set DEBUG based on CLI flags or environment variable
DEBUG="${CLI_VERBOSE:-${CLI_DEBUG:-${QUERY_RUNNER_DEBUG:-0}}}"
if [[ "$DEBUG" != "0" && "$DEBUG" != "false" ]]; then
    debug "Debug mode enabled (DEBUG=$DEBUG)."
fi

# Load environment
load_env

# Get query
if [[ -n "$QUERY_FILE" ]]; then
    # Normalize/harden path
    normalized_query_file=$(normalize_query_file_path "$QUERY_FILE") || true
    if [[ -z "$normalized_query_file" ]]; then
        echo "Error: Invalid or unsafe query file path: $QUERY_FILE" >&2
        exit 1
    fi
    if [[ "$normalized_query_file" == "-" ]]; then
        # Read from stdin if explicit - provided
        query=$(cat -)
    else
        if [[ ! -f "$normalized_query_file" ]]; then
            echo "Error: Query file not found: $normalized_query_file" >&2
            exit 1
        fi
        query=$(cat -- "$normalized_query_file")
    fi
else
    query=$(cat)
fi

# Execute
execute_query "$query" "$CLI_FORMAT"
