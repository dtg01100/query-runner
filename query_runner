#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"
DRIVERS_DIR="$SCRIPT_DIR/drivers"
CACHE_DIR="$HOME/.query_runner/cache"

# Java binaries
JAVA_BIN=""
JAVAC_BIN=""

# Default debug flag from environment variable - CLI can override
QUERY_RUNNER_DEBUG="${QUERY_RUNNER_DEBUG:-0}"

# Cache management functions
init_cache() {
    [[ -d "$CACHE_DIR" ]] || mkdir -p "$CACHE_DIR"
}

get_source_hash() {
    # Hash of the query_runner script itself
    md5sum "$0" | cut -d' ' -f1
}

get_drivers_hash() {
    # Hash of all JAR files in drivers directory
    local drivers_hash=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_hash=$(find "$DRIVERS_DIR" -name "*.jar" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
    fi
    echo "$drivers_hash"
}

get_cache_key() {
    local source_hash
    local drivers_hash
    source_hash=$(get_source_hash)
    drivers_hash=$(get_drivers_hash)
    echo "${source_hash}_${drivers_hash}"
}

get_cache_dir_for_key() {
    local cache_key="$1"
    echo "$CACHE_DIR/$cache_key"
}

# Debug helper: echo messages only when DEBUG is enabled
debug() {
    local debug_val="${DEBUG:-$QUERY_RUNNER_DEBUG}"
    if [[ "$debug_val" != "0" && "$debug_val" != "false" ]]; then
        echo "DEBUG: $*" >&2
    fi
}

# Enhanced path validation with stricter security controls
validate_path_input() {
    local path="$1"
    local context="$2"  # "query", "database", "env", etc.
    
    # Reject null bytes and control characters
    if printf '%s' "$path" | grep -qP '\x00|[\x01-\x1F\x7F]'; then
        echo "Error: Invalid control characters in $context path" >&2
        exit 1
    fi
    
    # Length validation
    if [[ ${#path} -gt 4096 ]]; then
        echo "Error: $context path too long (maximum 4096 characters)" >&2
        exit 1
    fi
    
    # Check for suspicious patterns
    case "$context" in
        "query")
            # Query files should not contain certain patterns
            if [[ "$path" =~ \.\./ ]] || [[ "$path" =~ ~.*[/.].*\. ]]; then
                echo "Error: Invalid query file path" >&2
                exit 1
            fi
            ;;
        "database")
            # Database paths have specific restrictions
            if [[ "$path" =~ \.\./ ]] && [[ ! "$path" =~ ^/ ]]; then
                echo "Error: Invalid database path" >&2
                exit 1
            fi
            ;;
        "env"|"drivers")
            # Environment and drivers paths
            if [[ "$path" =~ \.\./ ]] && [[ ! "$path" =~ ^/ ]]; then
                echo "Error: Invalid $context path" >&2
                exit 1
            fi
            ;;
    esac
}

# Enhanced normalize_query_file_path with better security
normalize_query_file_path() {
    local path="$1"
    
    # Validate input first
    validate_path_input "$path" "query"
    
    # Reject CR and NUL characters explicitly, then trim whitespace
    # Detect NUL bytes if `od` is available
    if command -v od >/dev/null 2>&1; then
        if printf '%s' "$path" | od -An -t x1 -v | grep -q -E '(^| )00($| )'; then
            return 1
        fi
    else
        # Fallback: detect control characters including carriage return via awk
        if printf '%s' "$path" | awk '/[[:cntrl:]]/ { exit 1 }'; then
            :
        else
            return 1
        fi
    fi
    
    # Reject any carriage returns or tabs or newline characters explicitly
    case "$path" in
        *$'\r'*|*$'\n'*|*$'\t'*)
            return 1
            ;;
    esac
    
    # Trim leading/trailing whitespace (spaces and tabs)
    path=$(printf '%s' "$path" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

    # Reject paths containing newline/tab (weird terminals)
    case "$path" in
        *$'\n'*|*$'\t'*)
            return 1
            ;;
    esac

    # Expand ~ at beginning with validation
    if [[ "$path" == ~* ]]; then
        # expand ~ and ~user only for simple forms
        if [[ "$path" =~ ^~[a-zA-Z0-9_\-]+(/.*)?$ ]]; then
            # shell will expand ~user only when not quoted, so fallback to path as-is (no expansion)
            true
        else
            # Validate that HOME exists and is accessible
            if [[ -z "$HOME" ]] || [[ ! -d "$HOME" ]]; then
                return 1
            fi
            path="${path/#\~/$HOME}"
        fi
    fi

    # Fast path: '-' means stdin
    if [[ "$path" == "-" ]]; then
        printf '%s' "-"
        return 0
    fi

    # Security check: prevent access to sensitive directories
    case "$path" in
        /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
            echo "Error: Access to system directories is not allowed" >&2
            return 1
            ;;
    esac

    # If path exists, canonicalize; otherwise return path as provided
    if [[ -e "$path" ]]; then
        if command -v realpath >/dev/null 2>&1; then
            local canonical
            canonical=$(realpath -m -- "$path" 2>/dev/null || true)
            if [[ -n "$canonical" ]]; then
                # Additional security check: ensure we're not escaping allowed directories
                case "$canonical" in
                    /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
                        echo "Error: Access to system directories is not allowed" >&2
                        return 1
                        ;;
                    *)
                        printf '%s' "$canonical"
                        return 0
                        ;;
                esac
            fi
        fi
        if command -v readlink >/dev/null 2>&1; then
            local canonical2
            canonical2=$(readlink -f -- "$path" 2>/dev/null || true)
            if [[ -n "$canonical2" ]]; then
                # Additional security check for readlink result
                case "$canonical2" in
                    /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
                        echo "Error: Access to system directories is not allowed" >&2
                        return 1
                        ;;
                    *)
                        printf '%s' "$canonical2"
                        return 0
                        ;;
                esac
            fi
        fi
        # Fallback to absolute via cd
        local dir base abs
        dir=$(dirname -- "$path")
        base=$(basename -- "$path")
        if cd -- "$dir" 2>/dev/null; then
            abs="$PWD/$base"
            # Security check for fallback result
            case "$abs" in
                /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
                    echo "Error: Access to system directories is not allowed" >&2
                    return 1
                    ;;
                *)
                    printf '%s' "$abs"
                    return 0
                    ;;
            esac
        fi
    fi

    # If not found or canonicalization fails, return the trimmed path (may be relative)
    # But validate it doesn't contain dangerous patterns
    case "$path" in
        *../*)
            echo "Error: Path traversal attempt detected" >&2
            return 1
            ;;
        *)
            printf '%s' "$path"
            return 0
            ;;
    esac
}

# Generic wrapper for normalizing filesystem paths that can be used for both
# query files and database files. Keep a separate name for clarity.
normalize_fs_path() {
    local p
    p=$(normalize_query_file_path "$1") || return 1
    printf '%s' "$p"
}

is_cache_valid() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")

    [[ -d "$cache_path" ]] || return 1
    [[ -f "$cache_path/QueryRunner.class" ]] || return 1
    [[ -f "$cache_path/metadata.json" ]] || return 1

    # Check if cache is not too old (24 hours)
    local cache_age
    cache_age=$(find "$cache_path" -maxdepth 1 -type f -mtime +1 | wc -l)
    [[ $cache_age -eq 0 ]] || return 1

    return 0
}

save_to_cache() {
    local cache_key="$1"
    local temp_dir="$2"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")

    # Create cache directory
    mkdir -p "$cache_path"

    # Copy compiled class file
    cp "$temp_dir/QueryRunner.class" "$cache_path/"

    # Save metadata
    cat > "$cache_path/metadata.json" << 'EOF'
{
    "source_hash": "$(get_source_hash)",
    "drivers_hash": "$(get_drivers_hash)",
    "created_at": "$(date -Iseconds)",
    "query_runner_version": "1.0"
}
EOF
}

load_from_cache() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")
    echo "$cache_path/QueryRunner.class"
}

cleanup_old_cache() {
    # Remove cache directories older than 7 days
    find "$CACHE_DIR" -maxdepth 1 -type d -mtime +7 -exec rm -rf {} \; 2>/dev/null || true
}

check_java_availability() {
    if command -v java >/dev/null 2>&1 && command -v javac >/dev/null 2>&1; then
        JAVA_BIN=$(command -v java)
        JAVAC_BIN=$(command -v javac)
        return 0
    fi
    return 1
}

# Enhanced error handling with information leakage prevention
safe_exit() {
    local exit_code="$1"
    local message="$2"
    local sensitive_context="$3"
    
    # Sanitize error messages to prevent information leakage
    if [[ -n "$message" ]]; then
        # Remove potentially sensitive information from error messages
        message=$(echo "$message" | \
            sed -E 's/(password|passwd|pwd)[[:space:]]*[:=][[:space:]]*[^[:space:],;]+/\1=******/gi' | \
            sed -E 's/(user|username|uid)[[:space:]]*[:=][[:space:]]*[^[:space:],;]+/\1=******/gi' | \
            sed -E 's/(host|server|hostname)[[:space:]]*[:=][[:space:]]*[^[:space:],;]+/\1=******/gi' | \
            sed -E 's/jdbc:[^[:space:]]+/jdbc:*** CONNECTION_STRING ***/gi' | \
            sed -E 's/(localhost|127\.0\.0\.1|::1)/***HOST***/gi')
        
        # Only show detailed error messages in debug mode
        if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
            # In non-debug mode, show generic messages
            case "$sensitive_context" in
                "database"|"connection"|"jdbc")
                    echo "Error: Database connection failed" >&2
                    ;;
                "query"|"sql")
                    echo "Error: Query execution failed" >&2
                    ;;
                "file"|"path")
                    echo "Error: File operation failed" >&2
                    ;;
                "input"|"validation")
                    echo "Error: Input validation failed" >&2
                    ;;
                *)
                    echo "Error: Operation failed" >&2
                    ;;
            esac
        else
            # In debug mode, show sanitized but more detailed messages
            echo "Error: $message" >&2
        fi
    fi
    
    exit "$exit_code"
}

# Enhanced error handling function that prevents information leakage
handle_error() {
    local error_type="$1"
    local error_message="$2"
    local exit_code="${3:-1}"
    
    case "$error_type" in
        "database_connection")
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: Unable to connect to database" >&2
            else
                echo "Error: Database connection failed: $error_message" >&2
            fi
            ;;
        "sql_execution")
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: SQL query execution failed" >&2
            else
                echo "Error: SQL execution failed: $error_message" >&2
            fi
            ;;
        "input_validation")
            echo "Error: Input validation failed: $error_message" >&2
            ;;
        "file_access")
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: File access denied" >&2
            else
                echo "Error: File operation failed: $error_message" >&2
            fi
            ;;
        "security_violation")
            echo "Error: Security policy violation: $error_message" >&2
            ;;
        *)
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: Operation failed" >&2
            else
                echo "Error: $error_message" >&2
            fi
            ;;
    esac
    
    exit "$exit_code"
}

# Replace existing error handling with secure versions
download_standalone_jdk() {
    local java_version="21"
    local java_url="https://api.adoptium.net/v3/binary/latest/${java_version}/ga/linux/x64/jdk/hotspot/normal/adoptium"
    local java_archive="$CACHE_DIR/jdk.tar.gz"
    local java_dir="$CACHE_DIR/jdk"

    if [[ ! -d "$java_dir" ]]; then
        echo "Java is not found on your system." >&2
        read -p "Do you want to download a standalone JDK? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            handle_error "dependency" "Java is required to run this script" 1
        fi

        echo "Downloading standalone JDK..." >&2
        if ! curl -L -o "$java_archive" "$java_url" 2>/dev/null; then
            handle_error "download" "Failed to download JDK from $java_url" 1
        fi
        mkdir -p "$java_dir"
        if ! tar -xzf "$java_archive" -C "$java_dir" --strip-components=1 2>/dev/null; then
            handle_error "extract" "Failed to extract JDK archive" 1
        fi
        rm -f "$java_archive"
    fi

    JAVA_BIN="$java_dir/bin/java"
    JAVAC_BIN="$java_dir/bin/javac"

    # Verify the downloaded Java works
    if ! "$JAVA_BIN" -version >/dev/null 2>&1 || ! "$JAVAC_BIN" -version >/dev/null 2>&1; then
        handle_error "validation" "Downloaded JDK is not functional" 1
    fi
}

get_classpath_cache_key() {
    # Generate cache key based on drivers directory contents and timestamps
    local drivers_info=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_info=$(find "$DRIVERS_DIR" -name "*.jar" -type f -printf "%p|%T@\n" 2>/dev/null | sort | md5sum | cut -d' ' -f1)
    fi
    echo "classpath_${drivers_info}"
}

get_cached_classpath() {
    local cache_key="$1"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"

    if [[ -f "$cache_file" ]]; then
        # Check if cache is still valid (drivers haven't changed)
        local current_key
        current_key=$(get_classpath_cache_key)
        if [[ "$cache_key" == "$current_key" ]]; then
            debug "Using cached classpath file: $cache_file"
            cat "$cache_file"
            return 0
        fi
    fi

    return 1
}

save_classpath_cache() {
    local cache_key="$1"
    local classpath="$2"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"
    echo "$classpath" > "$cache_file"
}

build_classpath() {
    local jar_file="$1"
    local cache_key
    cache_key=$(get_classpath_cache_key)

    # Try to get from cache first
    local cached_classpath
    if cached_classpath=$(get_cached_classpath "$cache_key"); then
        debug "Using cached classpath: $cached_classpath"
        echo "$cached_classpath:$jar_file"
        return 0
    fi

    # Build classpath from scratch with lazy loading
    local classpath="$jar_file"
    local db_type
    db_type=$(detect_database_type)

    if [[ -d "$DRIVERS_DIR" ]]; then
        case "$db_type" in
            "mysql")
                for jar in "$DRIVERS_DIR"/*mysql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "postgresql")
                for jar in "$DRIVERS_DIR"/*postgresql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "oracle")
                for jar in "$DRIVERS_DIR"/*oracle*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlserver")
                for jar in "$DRIVERS_DIR"/*sqlserver*.jar "$DRIVERS_DIR"/*mssql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "db2")
                for jar in "$DRIVERS_DIR"/*db2*.jar "$DRIVERS_DIR"/*jt400*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "h2")
                for jar in "$DRIVERS_DIR"/*h2*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlite")
                for jar in "$DRIVERS_DIR"/*sqlite*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            *)
                # Fallback: include all JARs
                for jar in "$DRIVERS_DIR"/*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
        esac

        # Always include SLF4J dependencies if present
        for jar in "$DRIVERS_DIR"/slf4j*.jar; do
            [[ -f "$jar" ]] && classpath="$classpath:$jar"
        done
    fi

    # Save to cache
    save_classpath_cache "$cache_key" "$classpath"

    echo "$classpath"
}

get_precompiled_class() {
    # Check for pre-compiled QueryRunner.class in script directory
    local precompiled="$SCRIPT_DIR/QueryRunner.class"
    if [[ -f "$precompiled" ]]; then
        # Check if it's compatible with current script
        local script_hash
        script_hash=$(get_source_hash)
        local precompiled_hash_file="$SCRIPT_DIR/.query_runner_hash"

        if [[ -f "$precompiled_hash_file" ]]; then
            local stored_hash
            stored_hash=$(cat "$precompiled_hash_file")
            if [[ "$script_hash" == "$stored_hash" ]]; then
                echo "$precompiled"
                return 0
            fi
        fi
    fi

    return 1
}

save_precompiled_hash() {
    local script_hash
    script_hash=$(get_source_hash)
    echo "$script_hash" > "$SCRIPT_DIR/.query_runner_hash"
}

usage() {
    cat << 'EOF'
Usage: $(basename "$0") [OPTIONS] [QUERY_FILE]

Execute read-only SQL queries using JDBC with autoconfiguration.

Arguments:
    QUERY_FILE    Optional path to file containing SQL query.
                  If not provided, reads query from stdin.

Options:
    -f, --format FORMAT     Output format: text, csv, json, pretty
    -t, --type TYPE         Database type: mysql, postgresql, oracle, sqlserver,
                           db2, h2, sqlite (auto-detect if not specified)
    -h, --host HOST         Database host (overrides .env)
    -p, --port PORT         Database port (overrides .env)
    -d, --database DATABASE Database name (overrides .env)
    -u, --user USER         Database user (overrides .env)
    -P, --password PASSWORD Database password (overrides .env)
-e, --env-file FILE     Custom environment file (default: .env)
     --drivers-dir DIR       JDBC drivers directory (default: ./drivers)
     --list-drivers          List available database drivers and exit
     --test-connection       Test database connection and exit
     -v, --verbose           Enable verbose debug output (same as QUERY_RUNNER_DEBUG=1)
     --debug                 Alias for --verbose
     --download-driver TYPE  Download JDBC driver for TYPE (mysql, postgresql, h2, sqlite, sqlserver)
     --allow-union-tables TABLES  Comma-separated list of tables allowed in UNION queries
     -h, --help              Show this help message
    --                      End of options; next argument is interpreted as the query file (even if it starts with '-').

Examples:
    echo "SELECT * FROM users LIMIT 10" | $(basename "$0")
    $(basename "$0") -t mysql query.sql
    $(basename "$0") -f json --host localhost --port 5432 -t postgresql query.sql
    $(basename "$0") --test-connection

Environment:
    Uses .env file for database connection settings.
    Autoconfigures based on DB_TYPE.
    Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite
EOF
    exit 1
}

# Enhanced UNION safety detection with better pattern matching
check_union_safety() {
    local query="$1"
    local normalized_query
    local union_pattern_detected=false
    
    # Normalize query: lowercase, remove comments, collapse whitespace
    normalized_query=$(echo "$query" | tr '[:upper:]' '[:lower:]' | sed 's/--.*$//' | sed 's/\/\*.*\*\///g' | sed 's/\s\+/ /g' | xargs)

    debug "Checking UNION safety for normalized query: $normalized_query"

    # Allow UNION in safe contexts:
    # 1. WITH clauses (CTEs) - safe self-contained operations
    # 2. UNION ALL within same table - safe for data deduplication
    # 3. Explicitly allowed by user flag
    # 4. Subqueries that are clearly contained

    # Check for UNION in CTE context (safe)
    if [[ "$normalized_query" =~ with[[:space:]]+.*[[:space:]]+union[[:space:]]+(all[[:space:]]+)?select ]]; then
        debug "Allowing UNION in CTE context"
        return 0  # Allow UNION and UNION ALL in CTEs
    fi

    # Check for UNION ALL (safer than UNION DISTINCT)
    if [[ "$normalized_query" =~ union[[:space:]]+all[[:space:]]+select ]]; then
        # Still need to validate the tables involved
        debug "UNION ALL detected, checking table safety"
        union_pattern_detected=true
    fi

    # Check for basic UNION (more risky)
    if [[ "$normalized_query" =~ [^a-zA-Z0-9_]union[^a-zA-Z0-9_].*select ]]; then
        debug "Basic UNION detected, checking table safety"
        union_pattern_detected=true
    fi

    # If we detected a UNION pattern, do deeper analysis
    if [[ "$union_pattern_detected" == true ]]; then
        # Extract table names from the query for analysis
        local tables_in_query=()
        
        # Pattern to extract table names from FROM and JOIN clauses
        # This is a simplified extraction - real-world queries can be more complex
        while IFS= read -r table_name; do
            if [[ -n "$table_name" ]]; then
                # Clean up the table name
                table_name=$(echo "$table_name" | sed 's/[`,;().]*//g' | xargs)
                if [[ -n "$table_name" && ! "$table_name" =~ ^(select|from|join|where|and|or|not|in|null|true|false|as|on|using|group|order|limit|offset|union|intersect|except|with)$ ]]; then
                    tables_in_query+=("$table_name")
                fi
            fi
        done < <(echo "$normalized_query" | grep -oE 'from[[:space:]]+[a-zA-Z_][a-zA-Z0-9_]*|join[[:space:]]+[a-zA-Z_][a-zA-Z0-9_]*' | sed 's/.*[[:space:]]//' || true)

        debug "Extracted tables from query: ${tables_in_query[*]}"

        # Check for UNION between same table (safe)
        if [[ ${#tables_in_query[@]} -eq 2 ]] && [[ "${tables_in_query[0]}" == "${tables_in_query[1]}" ]]; then
            debug "Allowing UNION within same table: ${tables_in_query[0]}"
            return 0  # Allow UNION within same table
        fi

        # Check for UNION between multiple different tables (risky)
        if [[ ${#tables_in_query[@]} -gt 1 ]]; then
            local unique_tables=($(printf '%s\n' "${tables_in_query[@]}" | sort -u))
            if [[ ${#unique_tables[@]} -gt 1 ]]; then
                debug "Multiple different tables detected in UNION: ${unique_tables[*]}"
                
                # Check for explicit whitelist flag
                if [[ -n "${ALLOW_UNION_TABLES:-}" ]]; then
                    local allowed_tables
                    IFS=',' read -ra allowed_tables <<< "$ALLOW_UNION_TABLES"
                    local all_allowed=true
                    
                    for table in "${unique_tables[@]}"; do
                        local table_allowed=false
                        for allowed_table in "${allowed_tables[@]}"; do
                            allowed_table=$(echo "$allowed_table" | xargs)  # trim whitespace
                            if [[ "$table" == "$allowed_table" ]]; then
                                table_allowed=true
                                break
                            fi
                        done
                        if [[ "$table_allowed" == false ]]; then
                            all_allowed=false
                            break
                        fi
                    done
                    
                    if [[ "$all_allowed" == true ]]; then
                        debug "All tables in UNION are whitelisted: $ALLOW_UNION_TABLES"
                        return 0  # Allow UNION for whitelisted tables
                    else
                        debug "Some tables not in whitelist: allowed=$ALLOW_UNION_TABLES, found=${unique_tables[*]}"
                    fi
                fi
                
                # If we reach here, the UNION is not allowed
                echo "Error: UNION queries combining data from multiple different tables are not allowed by default." >&2
                echo "Found tables: ${unique_tables[*]}" >&2
                echo "For safe UNION operations, use:" >&2
                echo "  1. UNION ALL with the same table" >&2
                echo "  2. UNION in WITH clauses (CTEs)" >&2
                echo "  3. --allow-union-tables=table1,table2 flag for trusted tables" >&2
                echo "  4. Ensure all tables in the UNION are explicitly whitelisted" >&2
                exit 1
            fi
        fi

        # Check for complex subquery patterns that might be trying to bypass detection
        if [[ "$normalized_query" =~ \([[:space:]]*select.*union ]] || [[ "$normalized_query" =~ select.*\(.*union ]]; then
            debug "Complex subquery with UNION detected, performing additional validation"
            
            # Count the number of UNION occurrences
            local union_count=$(echo "$normalized_query" | grep -o "union" | wc -l)
            if [[ $union_count -gt 1 ]]; then
                echo "Error: Multiple UNION operations detected - this is not allowed for security reasons." >&2
                exit 1
            fi
        fi
    fi

    # If we haven't returned by now, the UNION pattern is not safe
    echo "Error: UNION queries are not allowed by default due to security concerns." >&2
    echo "For safe UNION operations, use:" >&2
    echo "  1. UNION ALL with the same table" >&2
    echo "  2. UNION in WITH clauses (CTEs)" >&2
    echo "  3. --allow-union-tables=table1,table2 flag for trusted tables" >&2
    exit 1
}

# Enhanced query normalization with better error handling
normalize_query_content() {
    local query="$1"
    local normalized_query
    
    # Normalize query: lowercase, remove comments, collapse whitespace
    # Use perl for more robust processing that handles edge cases
    if ! normalized_query=$(echo "$query" | perl -ne 'print lc' 2>/dev/null); then
        echo "Error: Failed to normalize query content" >&2
        echo "The query contains invalid characters or formatting issues." >&2
        exit 1
    fi
    
    if ! normalized_query=$(echo "$normalized_query" | perl -pe 's/--.*?$//g; s/\/\*.*?\*\///g; s/\s+/ /g;' 2>/dev/null); then
        echo "Error: Failed to process query comments and whitespace" >&2
        echo "The query contains malformed comments or special characters." >&2
        exit 1
    fi
    
    # Trim whitespace
    normalized_query=$(echo "$normalized_query" | xargs 2>/dev/null || echo "")
    
    if [[ -z "$normalized_query" ]]; then
        echo "Error: Query is empty or contains only whitespace/comments" >&2
        echo "Please provide a valid SQL query." >&2
        exit 1
    fi
    
    printf '%s' "$normalized_query"
}

check_read_only() {
    local query="$1"
    local normalized_query
    local query_length
    
    # Input length validation - prevent extremely long queries that could cause DoS
    query_length=${#query}
    if [[ $query_length -gt 1048576 ]]; then  # 1MB limit
        echo "Error: Query too long (maximum 1MB)" >&2
        echo "Please reduce the query size and try again." >&2
        exit 1
    fi
    
    # Remove null bytes and sanitize control characters, but allow common ones in string literals
    if printf '%s' "$query" | grep -qP '\x00'; then
        echo "Error: Query contains invalid null bytes" >&2
        echo "Please remove any binary data from the query." >&2
        exit 1
    fi
    
    # Normalize query with enhanced error handling
    normalized_query=$(normalize_query_content "$query") || {
        # The error message is already printed by normalize_query_content
        exit 1
    }

    # Check for dangerous patterns anywhere in the query
    local dangerous_patterns=(
        "insert "
        "update "
        "delete "
        "drop "
        "create "
        "alter "
        "truncate "
        "exec "
        "execute "
        "grant "
        "revoke "
        "commit "
        "rollback "
        "union "  # Will be validated with smart detection
        "load "   # LOAD DATA INFILE
        "copy "   # COPY command in PostgreSQL
        "backup " # BACKUP DATABASE
        "restore " # RESTORE DATABASE
    )

    for pattern in "${dangerous_patterns[@]}"; do
        if [[ "$normalized_query" =~ [[:space:]]$pattern ]]; then
            # Special handling for UNION - use smart detection
            if [[ "$pattern" == "union " ]]; then
                check_union_safety "$query"
            else
                echo "Error: Only read-only queries are allowed. Detected potentially dangerous pattern: $pattern" >&2
                echo "Please use only SELECT, WITH, SHOW, DESCRIBE, EXPLAIN, or PRAGMA statements." >&2
                exit 1
            fi
        fi
    done

    # Check for multiple statements (semicolon separation)
    if [[ "$normalized_query" == *";"* ]]; then
        echo "Error: Multiple SQL statements are not allowed" >&2
        echo "Each query must be a single SQL statement without semicolons." >&2
        exit 1
    fi

    # Query must start with a read-only operation
    if [[ ! "$normalized_query" =~ ^[[:space:]]*(select|with|show|describe|explain|pragma)[[:space:]] ]]; then
        echo "Error: Query must start with a read-only operation" >&2
        echo "Supported operations: SELECT, WITH, SHOW, DESCRIBE, EXPLAIN, PRAGMA" >&2
        echo "Example: SELECT * FROM users WHERE id = 1" >&2
        exit 1
    fi
}

detect_database_type() {
    local db_type="${DB_TYPE:-}"

    if [[ -n "$db_type" ]]; then
echo "$db_type"
        return 0
    fi

    # Try to detect from JDBC_URL if available
    if [[ -n "${JDBC_URL:-}" ]]; then
        case "$JDBC_URL" in
            *mysql*) echo "mysql"; return 0 ;;
            *postgresql*) echo "postgresql"; return 0 ;;
            *oracle*) echo "oracle"; return 0 ;;
            *sqlserver*) echo "sqlserver"; return 0 ;;
            *db2*) echo "db2"; return 0 ;;
            *h2*) echo "h2"; return 0 ;;
            *sqlite*) echo "sqlite"; return 0 ;;
        esac
    fi

    # Try to detect from available drivers
    if [[ -d "$DRIVERS_DIR" ]]; then
        if ls "$DRIVERS_DIR"/*mysql* 1> /dev/null 2>&1; then echo "mysql"; return 0; fi
        if ls "$DRIVERS_DIR"/*postgresql* 1> /dev/null 2>&1; then echo "postgresql"; return 0; fi
        if ls "$DRIVERS_DIR"/*oracle* 1> /dev/null 2>&1; then echo "oracle"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlserver* 1> /dev/null 2>&1; then echo "sqlserver"; return 0; fi
        if ls "$DRIVERS_DIR"/*db2* 1> /dev/null 2>&1; then echo "db2"; return 0; fi
        if ls "$DRIVERS_DIR"/*h2* 1> /dev/null 2>&1; then echo "h2"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlite* 1> /dev/null 2>&1; then echo "sqlite"; return 0; fi
    fi

    return 1
}

# Validate JDBC connection parameters
validate_jdbc_params() {
    local db_type="$1"
    local host="${2:-}"
    local port="${3:-}"
    local database="${4:-}"
    local user="${5:-}"
    local password="${6:-}"
    
    # Validate database type (already done in CLI validation)
    if ! [[ "$db_type" =~ ^(mysql|postgresql|oracle|sqlserver|db2|h2|sqlite)$ ]]; then
        echo "Error: Invalid database type: $db_type" >&2
        exit 1
    fi
    
    # Validate host (if provided)
    if [[ -n "$host" ]]; then
        # Length validation
        if [[ ${#host} -gt 255 ]]; then
            echo "Error: Host name too long" >&2
            exit 1
        fi
        
        # Basic hostname validation (allow localhost, IPs, and domain names)
        if ! [[ "$host" =~ ^[a-zA-Z0-9.-]+$ ]]; then
            echo "Error: Invalid host name format: $host" >&2
            exit 1
        fi
        
        # Reject potentially dangerous hosts
        case "$host" in
            /.*|.*\.\..*|.*\`.*|.*\$.*|.*\!.*)
                echo "Error: Invalid host name: $host" >&2
                exit 1
                ;;
        esac
    fi
    
    # Validate port (if provided)
    if [[ -n "$port" ]]; then
        if ! [[ "$port" =~ ^[0-9]+$ ]] || [[ $port -lt 1 ]] || [[ $port -gt 65535 ]]; then
            echo "Error: Invalid port number: $port" >&2
            exit 1
        fi
    fi
    
    # Validate database name/path
    if [[ -n "$database" ]]; then
        case "$db_type" in
            "sqlite"|"h2")
                # For file-based databases, validate the path
                if [[ "$database" != ":memory:" ]] && [[ "$database" != file:* ]] && [[ "$database" != jdbc:sqlite:* ]]; then
                    # Validate as file path
                    if ! validate_path_input "$database" "database"; then
                        echo "Error: Invalid database path: $database" >&2
                        exit 1
                    fi
                fi
                ;;
            *)
                # For server-based databases, validate database name
                if [[ ${#database} -gt 64 ]]; then
                    echo "Error: Database name too long" >&2
                    exit 1
                fi
                # Basic database name validation
                if ! [[ "$database" =~ ^[a-zA-Z0-9_/.-]+$ ]]; then
                    echo "Error: Invalid database name: $database" >&2
                    exit 1
                fi
                ;;
        esac
    fi
    
    # Validate user (if provided)
    if [[ -n "$user" ]]; then
        if [[ ${#user} -gt 64 ]]; then
            echo "Error: User name too long" >&2
            exit 1
        fi
        # Basic username validation
        if ! [[ "$user" =~ ^[a-zA-Z0-9_@.-]+$ ]]; then
            echo "Error: Invalid user name: $user" >&2
            exit 1
        fi
    fi
    
    # Validate password length (but don't validate content for security)
    if [[ -n "$password" ]]; then
        if [[ ${#password} -gt 1024 ]]; then
            echo "Error: Password too long" >&2
            exit 1
        fi
    fi
}

# Enhanced database configuration with validation
configure_database() {
    local db_type="$1"
    
    # Validate parameters before configuration
    validate_jdbc_params "$db_type" "${DB_HOST:-}" "${DB_PORT:-}" "${DB_DATABASE:-}" "${DB_USER:-}" "${DB_PASSWORD:-}"
    
    case "$db_type" in
        mysql)
            DB_PORT="${DB_PORT:-3306}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.mysql.cj.jdbc.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mysql-connector-java*.jar}"
            ;;
        postgresql)
            DB_PORT="${DB_PORT:-5432}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.postgresql.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-postgresql*.jar}"
            ;;
        oracle)
            DB_PORT="${DB_PORT:-1521}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-oracle.jdbc.OracleDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:oracle:thin:@${DB_HOST}:${DB_PORT}:${DB_DATABASE}?connectTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-ojdbc*.jar}"
            ;;
        sqlserver)
            DB_PORT="${DB_PORT:-1433}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.microsoft.sqlserver.jdbc.SQLServerDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:sqlserver://${DB_HOST}:${DB_PORT};databaseName=${DB_DATABASE};loginTimeout=${timeout};socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mssql-jdbc*.jar}"
            ;;
        db2)
            DB_PORT="${DB_PORT:-50000}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.ibm.db2.jcc.DB2Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:db2://${DB_HOST}:${DB_PORT}/${DB_DATABASE}:clientProgramName=${timeout};"
            fi
            DRIVER_JAR="${DRIVER_JAR:-db2jcc*.jar jt400*.jar}"
            ;;
        h2)
            DB_PORT="${DB_PORT:-9092}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.h2.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                JDBC_URL="jdbc:h2:tcp://${DB_HOST}:${DB_PORT}/${DB_DATABASE};loginTimeout=${timeout}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-h2*.jar}"
            ;;
        sqlite)
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.sqlite.JDBC}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                JDBC_URL="jdbc:sqlite:${DB_DATABASE}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-sqlite-jdbc*.jar}"
            ;;
        *)
            echo "Error: Unsupported database type: $db_type" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
            ;;
    esac
    
    # Validate JDBC URL format
    if [[ -n "${JDBC_URL:-}" ]]; then
        # Basic JDBC URL validation
        if [[ ! "$JDBC_URL" =~ ^jdbc: ]]; then
            echo "Error: Invalid JDBC URL format: $JDBC_URL" >&2
            exit 1
        fi
        
        # Check for potentially dangerous JDBC URL patterns
        if [[ "$JDBC_URL" =~ [\$\`\\\<\>\&\|\;] ]]; then
            echo "Error: JDBC URL contains potentially dangerous characters" >&2
            exit 1
        fi
        
        # Validate that the URL matches the expected database type
        case "$db_type" in
            mysql)
                if [[ ! "$JDBC_URL" =~ ^jdbc:mysql: ]]; then
                    echo "Error: JDBC URL does not match MySQL database type" >&2
                    exit 1
                fi
                ;;
            postgresql)
                if [[ ! "$JDBC_URL" =~ ^jdbc:postgresql: ]]; then
                    echo "Error: JDBC URL does not match PostgreSQL database type" >&2
                    exit 1
                fi
                ;;
            oracle)
                if [[ ! "$JDBC_URL" =~ ^jdbc:oracle: ]]; then
                    echo "Error: JDBC URL does not match Oracle database type" >&2
                    exit 1
                fi
                ;;
            sqlserver)
                if [[ ! "$JDBC_URL" =~ ^jdbc:sqlserver: ]]; then
                    echo "Error: JDBC URL does not match SQL Server database type" >&2
                    exit 1
                fi
                ;;
            db2)
                if [[ ! "$JDBC_URL" =~ ^jdbc:db2: ]]; then
                    echo "Error: JDBC URL does not match DB2 database type" >&2
                    exit 1
                fi
                ;;
            h2)
                if [[ ! "$JDBC_URL" =~ ^jdbc:h2: ]]; then
                    echo "Error: JDBC URL does not match H2 database type" >&2
                    exit 1
                fi
                ;;
            sqlite)
                if [[ ! "$JDBC_URL" =~ ^jdbc:sqlite: ]]; then
                    echo "Error: JDBC URL does not match SQLite database type" >&2
                    exit 1
                fi
                ;;
        esac
    fi
}

find_driver_jar() {
    local driver_pattern="$1"
    local jar_files=()

    # Search in drivers directory
    if [[ -d "$DRIVERS_DIR" ]]; then
        for pattern in $driver_pattern; do
            while IFS= read -r -d '' jar; do
                jar_files+=("$jar")
            done < <(find "$DRIVERS_DIR" -name "$pattern" -type f -print0 2>/dev/null)
        done
    fi

    # Search in script directory
    while IFS= read -r -d '' jar; do
        jar_files+=("$jar")
    done < <(find "$SCRIPT_DIR" -name "*.jar" -type f -print0 2>/dev/null)

    if [[ ${#jar_files[@]} -eq 0 ]]; then
echo "Error: No JDBC driver found matching pattern: $driver_pattern" >&2
echo "Please place the appropriate JDBC driver JAR in $DRIVERS_DIR or $SCRIPT_DIR" >&2
        exit 1
    fi

    # Return the first match
    echo "${jar_files[0]}"
}

list_drivers() {
    echo "Available database drivers:"
    echo "=========================="

    local found_drivers=()

    if [[ -d "$DRIVERS_DIR" ]]; then
        while IFS= read -r -d '' jar; do
            local basename
            basename=$(basename "$jar")
            case "$basename" in
                *mysql*) found_drivers+=("MySQL: $basename") ;;
                *postgresql*) found_drivers+=("PostgreSQL: $basename") ;;
                *oracle*) found_drivers+=("Oracle: $basename") ;;
                *sqlserver*|*mssql*) found_drivers+=("SQL Server: $basename") ;;
                *db2*|*jt400*) found_drivers+=("DB2/AS400: $basename") ;;
                *h2*) found_drivers+=("H2: $basename") ;;
                *sqlite*) found_drivers+=("SQLite: $basename") ;;
                *) found_drivers+=("Unknown: $basename") ;;
            esac
        done < <(find "$DRIVERS_DIR" -name "*.jar" -type f -print0 2>/dev/null)
    fi

    if [[ ${#found_drivers[@]} -eq 0 ]]; then
echo "No JDBC drivers found in $DRIVERS_DIR"
echo "Download drivers and place them in the drivers directory:"
echo "- MySQL: https://dev.mysql.com/downloads/connector/j/"
echo "- PostgreSQL: https://jdbc.postgresql.org/download/"
echo "- Oracle: https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html"
echo "- SQL Server: https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server"
echo "- DB2: https://www.ibm.com/support/pages/node/6331129"
echo "- H2: https://www.h2database.com/html/download.html"
echo "- SQLite: https://github.com/xerial/sqlite-jdbc/releases"
    else
        printf '%s\n' "${found_drivers[@]}"
    fi
}

download_driver() {
    local type="$1"
    local url=""
    local filename=""
    case "$type" in
        mysql)
            url="https://repo1.maven.org/maven2/com/mysql/mysql-connector-j/8.0.33/mysql-connector-j-8.0.33.jar"
            filename="mysql-connector-j-8.0.33.jar"
            ;;
        postgresql)
            url="https://repo1.maven.org/maven2/org/postgresql/postgresql/42.6.0/postgresql-42.6.0.jar"
            filename="postgresql-42.6.0.jar"
            ;;
        h2)
            url="https://repo1.maven.org/maven2/com/h2database/h2/2.1.214/h2-2.1.214.jar"
            filename="h2-2.1.214.jar"
            ;;
        sqlite)
            url="https://repo1.maven.org/maven2/org/xerial/sqlite-jdbc/3.42.0.0/sqlite-jdbc-3.42.0.0.jar"
            filename="sqlite-jdbc-3.42.0.0.jar"
            ;;
        sqlserver)
            url="https://repo1.maven.org/maven2/com/microsoft/sqlserver/mssql-jdbc/12.4.1.jre11/mssql-jdbc-12.4.1.jre11.jar"
            filename="mssql-jdbc-12.4.1.jre11.jar"
            ;;
        *)
            echo "Error: Unsupported driver type: $type" >&2
            exit 1
            ;;
    esac
    mkdir -p "$DRIVERS_DIR"
    local dest="$DRIVERS_DIR/$filename"
    if [[ -f "$dest" ]]; then
        echo "Driver already exists: $dest" >&2
        return 0
    fi
    echo "Downloading $type driver from $url..." >&2
    if ! curl -L -o "$dest" "$url"; then
        echo "Error: Failed to download $url" >&2
        exit 1
    fi
    echo "Downloaded $type driver to $dest" >&2
}

test_connection() {
    local test_query="SELECT 1"
    execute_query "$test_query" "text" > /dev/null
    echo "Connection successful!" >&2
}

load_env() {
    local env_file_to_use="$ENV_FILE"
    
    # Use custom env file if specified
    if [[ -n "${CLI_ENV_FILE:-}" ]]; then
        env_file_to_use="$CLI_ENV_FILE"
    fi
    
    # Validate env file path first
    if ! normalize_fs_path "$env_file_to_use" >/dev/null 2>&1; then
        echo "Error: Invalid environment file path: $env_file_to_use" >&2
        exit 1
    fi
    
    if [[ ! -f "$env_file_to_use" ]]; then
        echo "Warning: Environment file not found at $env_file_to_use" >&2
        echo "You can specify connection details via command line options" >&2
    else
        # Secure environment file parsing
        set -a
        
        # Use a secure method to parse the environment file
        # Only allow valid environment variable names and values
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Skip lines that don't contain an equals sign
            [[ ! "$line" =~ ^[^=]+=[^=]*$ ]] && continue
            
            # Extract variable name and value
            local var_name="${line%%=*}"
            local var_value="${line#*=}"
            
            # Validate variable name (only allow alphanumeric and underscore)
            if ! [[ "$var_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                debug "Skipping invalid environment variable name: $var_name"
                continue
            fi
            
            # Validate variable value length
            if [[ ${#var_value} -gt 4096 ]]; then
                echo "Error: Environment variable value too long: $var_name" >&2
                exit 1
            fi
            
            # Remove surrounding quotes if present
            if [[ "$var_value" =~ ^[\"'](.*)[\"']$ ]]; then
                var_value="${BASH_REMATCH[1]}"
            fi
            
            # Set the environment variable safely
            export "$var_name=$var_value"
            
            # Debug logging (sanitized)
            case "$var_name" in
                *PASSWORD*|*SECRET*|*KEY*)
                    debug "Loaded environment variable: $var_name=******"
                    ;;
                *)
                    debug "Loaded environment variable: $var_name=$var_value"
                    ;;
            esac
        done < "$env_file_to_use"
        
        set +a
    fi

    # Override with command line arguments if provided (already validated)
    DB_HOST="${CLI_HOST:-${DB_HOST:-localhost}}"
    DB_PORT="${CLI_PORT:-${DB_PORT:-}}"
    DB_DATABASE="${CLI_DATABASE:-${DB_DATABASE:-}}"
    DB_USER="${CLI_USER:-${DB_USER:-}}"
    DB_PASSWORD="${CLI_PASSWORD:-${DB_PASSWORD:-}}"

    # Auto-detect or use specified database type (already validated)
    local db_type
    if [[ -n "${CLI_TYPE:-}" ]]; then
        db_type="$CLI_TYPE"
    else
        if ! db_type=$(detect_database_type); then
            echo "Error: Could not auto-detect database type" >&2
            echo "Please specify DB_TYPE in .env or use -t option" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
        fi
    fi
    debug "Using database type: $db_type"
    
    # If using SQLite or H2, normalize DB_DATABASE path (unless in-memory or file: URI)
    if [[ -n "${DB_DATABASE:-}" && ("$db_type" == "sqlite" || ("$db_type" == "h2" && ("${DB_DATABASE}" == ~* || "${DB_DATABASE}" == /* || "${DB_DATABASE}" == */* || "${DB_DATABASE}" == ./*))) ]]; then
        case "${DB_DATABASE}" in
            ":memory:")
                debug "SQLite in-memory DB requested; skipping path normalization"
                ;;
            file:*)
                debug "SQLite file URI detected; skipping path normalization: ${DB_DATABASE}"
                ;;
            jdbc:sqlite:*)
                debug "SQLite JDBC URL detected; skipping path normalization: ${DB_DATABASE}"
                ;;
            *)
                # Normalize path and convert to absolute form if possible
                normalized_db=$(normalize_fs_path "${DB_DATABASE}") || { echo "Error: Invalid database path: ${DB_DATABASE}" >&2; exit 1; }
                # Convert to absolute if possible (use realpath -m if available)
                if [[ "${normalized_db}" != /* ]]; then
                    if command -v realpath >/dev/null 2>&1; then
                        normalized_db=$(realpath -m -- "${normalized_db}" 2>/dev/null || printf '%s' "${normalized_db}")
                    else
                        local db_dir db_base
                        db_dir=$(dirname -- "${normalized_db}" 2>/dev/null || printf '%s' "${normalized_db}")
                        db_base=$(basename -- "${normalized_db}" 2>/dev/null || printf '%s' "${normalized_db}")
                        if cd -- "${db_dir}" 2>/dev/null; then
                            normalized_db="$PWD/$db_base"
                        fi
                    fi
                fi
                DB_DATABASE="$normalized_db"
                debug "Normalized DB path: $DB_DATABASE"
                ;;
        esac
    fi
    
    # For H2, if we normalized above we still may want to log
    if [[ "$db_type" == "h2" && -n "${DB_DATABASE:-}" ]]; then
        debug "Final H2 DB identifier: $DB_DATABASE"
    fi
    configure_database "$db_type"

    # Find the appropriate driver JAR (already validated)
    JAR_FILE=$(find_driver_jar "$DRIVER_JAR")
    debug "Using driver: $(basename "$JAR_FILE")"

    # Validate required variables (already done for CLI, now for env vars)
    if [[ "$db_type" != "sqlite" ]]; then
        required_vars=("DB_HOST" "DB_USER" "DB_PASSWORD")
        for var in "${required_vars[@]}"; do
            if [[ -z "${!var:-}" ]]; then
                echo "Error: Required environment variable $var is not set" >&2
                exit 1
            fi
        done
    fi

    if [[ -z "${DB_DATABASE:-}" && "$db_type" != "sqlite" ]]; then
        echo "Error: Database name is required" >&2
        exit 1
    fi
}

execute_query() {
    local query="$1"
    local format="$2"
    local temp_dir
    temp_dir=$(mktemp -d)
    trap 'rm -rf "${temp_dir:-}"' EXIT

    local temp_java_file cache_key cached_class_file

    check_read_only "$query"

    # Check for pre-compiled class first
    local precompiled_class
    local compilation_dir

    if precompiled_class=$(get_precompiled_class); then
        compilation_dir=$(dirname "$precompiled_class")
        debug "Using precompiled class in $compilation_dir"
    else
        # Initialize cache and check for valid cached compilation
        init_cache
        cleanup_old_cache
        cache_key=$(get_cache_key)

        if is_cache_valid "$cache_key"; then
            cached_class_file=$(load_from_cache "$cache_key")
            compilation_dir=$(dirname "$cached_class_file")
            debug "Using cached compiled class in $compilation_dir"
        else
            # Need to compile
            compilation_dir="$temp_dir"
            temp_java_file="$compilation_dir/QueryRunner.java"

cat > "$temp_java_file" << 'EOF'
import java.sql.*;
import java.util.*;
import java.util.regex.*;

public class QueryRunner {

    private static boolean isDebug() {
        String v = System.getenv("QUERY_RUNNER_DEBUG");
        return v != null && (v.equals("1") || v.equalsIgnoreCase("true"));
    }

    private static void debug(String msg) {
        if (isDebug()) System.err.println("DEBUG: " + msg);
    }

    private static String maskJdbcUrl(String url) {
        if (url == null) return null;
        // Mask password= param in JDBC URL if present
        try {
            return url.replaceAll("(?i)(password=)([^&;]+)", "$1******");
        } catch (Exception e) {
            return url;
        }
    }

    public static void main(String[] args) {
        String query = "";
        Scanner scanner = new Scanner(System.in);
        if (scanner.hasNextLine()) {
            query = scanner.useDelimiter("\\A").next();
        }
        String url = System.getenv("JDBC_URL");
        String driver = System.getenv("JDBC_DRIVER_CLASS");
        String user = System.getenv("DB_USER");
        String password = System.getenv("DB_PASSWORD");
        String format = System.getenv("OUTPUT_FORMAT");
        if (format == null) format = "text";
        debug("JDBC driver class: " + driver);
        debug("JDBC URL: " + maskJdbcUrl(url));
        debug("DB user: " + (user == null ? "(none)" : user));
        try {
            Class.forName(driver);
        } catch (ClassNotFoundException e) {
            System.err.println("Error: JDBC driver not found: " + e.getMessage());
            System.exit(1);
        }

        try (Connection conn = DriverManager.getConnection(url, user, password);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {

            ResultSetMetaData meta = rs.getMetaData();
            int columnCount = meta.getColumnCount();
            List<String> columnNames = new ArrayList<>();
            for (int i = 1; i <= columnCount; i++) {
                columnNames.add(meta.getColumnName(i));
            }

            switch (format) {
                case "pretty":
                    // For pretty format, load all rows to calculate widths
                    List<Map<String, Object>> rows = new ArrayList<>();
                    while (rs.next()) {
                        Map<String, Object> row = new HashMap<>();
                        for (int i = 1; i <= columnCount; i++) {
                            row.put(columnNames.get(i-1), rs.getObject(i));
                        }
                        rows.add(row);
                    }
                    outputPretty(columnNames, rows);
                    break;
                case "json":
                    outputJsonStream(columnNames, rs);
                    break;
                case "csv":
                    outputCsvStream(columnNames, rs);
                    break;
                case "text":
                default:
                    outputTextStream(columnNames, rs);
                    break;
            }
        } catch (SQLException e) {
            System.err.println("SQL Error: " + e.getMessage());
            System.err.println("SQL State: " + e.getSQLState());
            System.err.println("Error Code: " + e.getErrorCode());
            if (isDebug()) {
                e.printStackTrace(System.err);
            }
            System.exit(1);
        }
    }

    private static String escapeJson(String str) {
        if (str == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            switch (c) {
                case '\\':
                case '"':
                    sb.append('\\').append(c);
                    break;
                case '\b':
                    sb.append("\\b");
                    break;
                case '\t':
                    sb.append("\\t");
                    break;
                case '\n':
                    sb.append("\\n");
                    break;
                case '\f':
                    sb.append("\\f");
                    break;
                case '\r':
                    sb.append("\\r");
                    break;
                default:
                    if (c < ' ') {
                        String t = "000" + Integer.toHexString(c);
                        sb.append("\\u").append(t.substring(t.length() - 4));
                    } else {
                        sb.append(c);
                    }
            }
        }
        return sb.toString();
    }

    private static String repeatString(String str, int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {
            sb.append(str);
        }
        return sb.toString();
    }

    private static void outputJsonStream(List<String> columnNames, ResultSet rs) throws SQLException {
        System.out.print("[");
        boolean first = true;
        while (rs.next()) {
            if (!first) System.out.print(",");
            first = false;
            System.out.print("{");
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                System.out.print("\"" + escapeJson(columnNames.get(i)) + "\":");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("null");
                } else if (value instanceof Number || value instanceof Boolean) {
                    System.out.print(value.toString());
                } else {
                    System.out.print("\"" + escapeJson(value.toString()) + "\"");
                }
            }
            System.out.print("}");
        }
        System.out.println("]");
    }

    private static void outputCsvStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print(",");
            System.out.print("\"" + columnNames.get(i).replace("\"", "\"\"") + "\"");
        }
        System.out.println();
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("");
                } else {
                    String strValue = value.toString();
                    System.out.print("\"" + strValue.replace("\"", "\"\"") + "\"");
                }
            }
            System.out.println();
        }
    }



    private static void outputTextStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print("\t");
            System.out.print(columnNames.get(i));
        }
        System.out.println();
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print("\t");
                Object value = rs.getObject(i + 1);
                System.out.print(value != null ? value.toString() : "NULL");
            }
            System.out.println();
        }
    }

    private static void outputPretty(List<String> columnNames, List<Map<String, Object>> rows) {
        int[] maxWidths = new int[columnNames.size()];
        for (int i = 0; i < columnNames.size(); i++) {
            maxWidths[i] = columnNames.get(i).length();
        }
        for (Map<String, Object> row : rows) {
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                maxWidths[i] = Math.max(maxWidths[i], strValue.length());
            }
        }
        String separator = "+";
        for (int width : maxWidths) {
            separator += repeatString("-", width + 2) + "+";
        }
        System.out.println(separator);
        System.out.print("|");
        for (int i = 0; i < columnNames.size(); i++) {
            System.out.print(" " + String.format("%-" + maxWidths[i] + "s", columnNames.get(i)) + " |");
        }
        System.out.println();
        System.out.println(separator);
        for (Map<String, Object> row : rows) {
            System.out.print("|");
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                System.out.print(" " + String.format("%-" + maxWidths[i] + "s", strValue) + " |");
            }
            System.out.println();
        }
        System.out.println(separator);
    }
}
EOF

    debug "Compiling temporary Java file: $temp_java_file"
    if ! javac_output=$("$JAVAC_BIN" "$temp_java_file" 2>&1); then
            echo "Error: Failed to compile Java code" >&2
            echo "Compilation error details:" >&2
            echo "$javac_output" >&2
            exit 1
        fi
        # Save to cache for future use
        save_to_cache "$cache_key" "$compilation_dir"
        debug "Compiled and saved class to cache at $compilation_dir"
        fi
    fi
    local classpath
    classpath=$(build_classpath "$JAR_FILE")
    export OUTPUT_FORMAT="$format" JDBC_URL JDBC_DRIVER_CLASS DB_USER DB_PASSWORD
    # Pass DEBUG to Java process as QUERY_RUNNER_DEBUG env var so the Java runner can also print debug info
    export QUERY_RUNNER_DEBUG="${DEBUG:-${QUERY_RUNNER_DEBUG:-0}}"
    echo -n "$query" | "$JAVA_BIN" --enable-native-access=ALL-UNNAMED -cp "$classpath:$compilation_dir" QueryRunner
    debug "Running java: $JAVA_BIN -cp $classpath:$compilation_dir QueryRunner"
}

# Check for Java availability
if ! check_java_availability; then
    download_standalone_jdk
fi

# Enhanced validate_cli_option with better error messages
validate_cli_option() {
    local option="$1"
    local value="$2"
    
    # Reject null bytes
    if printf '%s' "$value" | grep -qP '\x00'; then
        echo "Error: Invalid null bytes in $option value" >&2
        echo "Please remove any binary data from the $option parameter." >&2
        exit 1
    fi
    
    # Length validation for security (more reasonable limits)
    local value_length=${#value}
    case "$option" in
        "host"|"user"|"password")
            if [[ $value_length -gt 1024 ]]; then
                echo "Error: $option value too long (maximum 1024 characters)" >&2
                echo "Please reduce the $option length and try again." >&2
                exit 1
            fi
            # For host, allow common characters but reject dangerous ones
            if [[ "$option" == "host" ]]; then
                if [[ "$value" =~ [\\\<\>\&\|\;\`] ]]; then
                    echo "Error: Invalid characters in host name" >&2
                    echo "Host names should contain only letters, numbers, dots, and hyphens." >&2
                    exit 1
                fi
            fi
            ;;
        "database")
            if [[ $value_length -gt 2048 ]]; then
                echo "Error: Database value too long (maximum 2048 characters)" >&2
                echo "Please reduce the database name/path length and try again." >&2
                exit 1
            fi
            # Allow database names with reasonable characters
            if [[ "$value" =~ [\\\<\>\&\|\;\`] ]]; then
                echo "Error: Invalid characters in database name" >&2
                echo "Database names should not contain special shell characters." >&2
                exit 1
            fi
            ;;
        "port")
            if [[ $value_length -gt 5 ]]; then
                echo "Error: Port value too long" >&2
                echo "Port numbers should be 1-5 digits long." >&2
                exit 1
            fi
            # Validate port is numeric
            if ! [[ "$value" =~ ^[0-9]+$ ]] || [[ $value -lt 1 ]] || [[ $value -gt 65535 ]]; then
                echo "Error: Invalid port number: $value" >&2
                echo "Port numbers must be between 1 and 65535." >&2
                exit 1
            fi
            ;;
        "format")
            if [[ $value_length -gt 20 ]]; then
                echo "Error: Format value too long" >&2
                echo "Output format names should be shorter than 20 characters." >&2
                exit 1
            fi
            # Validate format is one of the allowed values
            if ! [[ "$value" =~ ^(text|csv|json|pretty)$ ]]; then
                echo "Error: Invalid format. Supported: text, csv, json, pretty" >&2
                echo "Please choose one of the supported output formats." >&2
                exit 1
            fi
            ;;
        "type")
            if [[ $value_length -gt 20 ]]; then
                echo "Error: Database type value too long" >&2
                echo "Database type names should be shorter than 20 characters." >&2
                exit 1
            fi
            # Validate database type
            if ! [[ "$value" =~ ^(mysql|postgresql|oracle|sqlserver|db2|h2|sqlite)$ ]]; then
                echo "Error: Invalid database type. Supported: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
                echo "Please choose one of the supported database types." >&2
                exit 1
            fi
            ;;
        "env-file"|"drivers-dir")
            # Validate file system paths
            if ! normalize_fs_path "$value" >/dev/null 2>&1; then
                echo "Error: Invalid path for $option: $value" >&2
                echo "Please provide a valid file system path." >&2
                echo "Paths should not contain control characters or binary data." >&2
                exit 1
            fi
            ;;
        "allow-union-tables")
            if [[ $value_length -gt 2048 ]]; then
                echo "Error: Union tables list too long" >&2
                echo "Please reduce the number of tables in the whitelist." >&2
                exit 1
            fi
            # Validate table names contain only safe characters (more permissive)
            if [[ "$value" =~ [\\\<\>\&\|\;\`] ]]; then
                echo "Error: Invalid characters in table names for allow-union-tables" >&2
                echo "Table names should not contain shell metacharacters." >&2
                exit 1
            fi
            ;;
    esac
    
    # Return the validated value
    printf '%s' "$value"
}

# Initialize CLI variables
CLI_HOST=""
CLI_PORT=""
CLI_DATABASE=""
CLI_USER=""
CLI_PASSWORD=""
CLI_TYPE=""
CLI_FORMAT="text"
CLI_ENV_FILE=""
ALLOW_UNION_TABLES=""
DOWNLOAD_DRIVER=""
QUERY_FILE=""

# Enhanced command line parsing with validation
while [[ $# -gt 0 ]]; do
    case $1 in
        --)
            # End of options; treat the next argument as the query file (even if it starts with -)
            shift
            if [[ $# -ge 1 ]]; then
                QUERY_FILE="$1"
                shift
            fi
            break
            ;;
        -f|--format)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --format requires a value" >&2
                usage
            fi
            CLI_FORMAT=$(validate_cli_option "format" "$2")
            shift 2
            ;;
        -t|--type)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --type requires a value" >&2
                usage
            fi
            CLI_TYPE=$(validate_cli_option "type" "$2")
            shift 2
            ;;
        -h|--host)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --host requires a value" >&2
                usage
            fi
            CLI_HOST=$(validate_cli_option "host" "$2")
            shift 2
            ;;
        -p|--port)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --port requires a value" >&2
                usage
            fi
            CLI_PORT=$(validate_cli_option "port" "$2")
            shift 2
            ;;
        -d|--database)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --database requires a value" >&2
                usage
            fi
            CLI_DATABASE=$(validate_cli_option "database" "$2")
            shift 2
            ;;
        -u|--user)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --user requires a value" >&2
                usage
            fi
            CLI_USER=$(validate_cli_option "user" "$2")
            shift 2
            ;;
        -P|--password)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --password requires a value" >&2
                usage
            fi
            CLI_PASSWORD=$(validate_cli_option "password" "$2")
            shift 2
            ;;
        -e|--env-file)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --env-file requires a value" >&2
                usage
            fi
            CLI_ENV_FILE=$(validate_cli_option "env-file" "$2")
            shift 2
            ;;
        --drivers-dir)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --drivers-dir requires a value" >&2
                usage
            fi
            DRIVERS_DIR=$(validate_cli_option "drivers-dir" "$2")
            shift 2
            ;;
        --list-drivers)
            list_drivers
            exit 0
            ;;
        --test-connection)
            load_env
            test_connection
            exit 0
            ;;
        --download-driver)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --download-driver requires a value" >&2
                usage
            fi
            DOWNLOAD_DRIVER=$(validate_cli_option "type" "$2")
            shift 2
            ;;
--allow-union-tables)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --allow-union-tables requires a value" >&2
                usage
            fi
            ALLOW_UNION_TABLES=$(validate_cli_option "allow-union-tables" "$2")
            shift 2
            ;;
--debug)
            CLI_DEBUG=1
            DEBUG=1
            shift
            ;;
        --help)
            usage
            ;;
        -*)
            echo "Unknown option: $1" >&2
            usage
            ;;
        *)
            # Validate query file path
            if ! normalize_query_file_path "$1" >/dev/null 2>&1; then
                echo "Error: Invalid query file path: $1" >&2
                exit 1
            fi
            QUERY_FILE="$1"
            shift
            ;;
    esac
done

if [[ -n "$DOWNLOAD_DRIVER" ]]; then
    download_driver "$DOWNLOAD_DRIVER"
    exit 0
fi

# Set DEBUG based on CLI flags or environment variable
DEBUG="${CLI_VERBOSE:-${CLI_DEBUG:-${QUERY_RUNNER_DEBUG:-0}}}"
if [[ "$DEBUG" != "0" && "$DEBUG" != "false" ]]; then
    debug "Debug mode enabled (DEBUG=$DEBUG)."
fi

# Load environment
load_env

# Get query
if [[ -n "$QUERY_FILE" ]]; then
    # Normalize/harden path
    normalized_query_file=$(normalize_query_file_path "$QUERY_FILE") || {
        echo "Error: Invalid or unsafe query file path: $QUERY_FILE" >&2
        echo "Please check the file path and ensure it contains only valid characters." >&2
        exit 1
    }
    
    if [[ "$normalized_query_file" == "-" ]]; then
        # Read from stdin if explicit - provided
        query=$(cat -) || {
            echo "Error: Failed to read from stdin" >&2
            exit 1
        }
    else
        if [[ ! -f "$normalized_query_file" ]]; then
            echo "Error: Query file not found: $normalized_query_file" >&2
            echo "Please check the file path and ensure the file exists." >&2
            exit 1
        fi
        
        if [[ ! -r "$normalized_query_file" ]]; then
            echo "Error: Cannot read query file: $normalized_query_file" >&2
            echo "Please check file permissions." >&2
            exit 1
        fi
        
        query=$(cat -- "$normalized_query_file") || {
            echo "Error: Failed to read query file: $normalized_query_file" >&2
            echo "Please check file permissions and ensure the file is not corrupted." >&2
            exit 1
        }
    fi
else
    # Read from stdin with proper error handling
    if ! query=$(cat -) 2>/dev/null; then
        if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
            echo "Error: Failed to read query from stdin" >&2
            echo "Please ensure input is properly formatted and not truncated." >&2
            exit 1
        fi
        query=""
    fi
fi

# Validate that we have a query
if [[ -z "$query" ]]; then
    echo "Error: No query provided" >&2
    echo "Usage: $0 [OPTIONS] [QUERY_FILE]" >&2
    echo "   or: echo 'SELECT * FROM table' | $0 [OPTIONS]" >&2
    exit 1
fi

# Execute
execute_query "$query" "$CLI_FORMAT"
