#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"
DRIVERS_DIR="$SCRIPT_DIR/drivers"
CACHE_DIR="$HOME/.query_runner/cache"

# Cache management functions
init_cache() {
    [[ -d "$CACHE_DIR" ]] || mkdir -p "$CACHE_DIR"
}

get_source_hash() {
    # Hash of the query_runner script itself
    md5sum "$0" | cut -d' ' -f1
}

get_drivers_hash() {
    # Hash of all JAR files in drivers directory
    local drivers_hash=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_hash=$(find "$DRIVERS_DIR" -name "*.jar" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
    fi
    echo "$drivers_hash"
}

get_cache_key() {
    local source_hash
    local drivers_hash
    source_hash=$(get_source_hash)
    drivers_hash=$(get_drivers_hash)
    echo "${source_hash}_${drivers_hash}"
}

get_cache_dir_for_key() {
    local cache_key="$1"
    echo "$CACHE_DIR/$cache_key"
}

is_cache_valid() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")
    
    [[ -d "$cache_path" ]] || return 1
    [[ -f "$cache_path/QueryRunner.class" ]] || return 1
    [[ -f "$cache_path/metadata.json" ]] || return 1
    
    # Check if cache is not too old (24 hours)
    local cache_age
    cache_age=$(find "$cache_path" -maxdepth 1 -type f -mtime +1 | wc -l)
    [[ $cache_age -eq 0 ]] || return 1
    
    return 0
}

save_to_cache() {
    local cache_key="$1"
    local temp_dir="$2"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")
    
    # Create cache directory
    mkdir -p "$cache_path"
    
    # Copy compiled class file
    cp "$temp_dir/QueryRunner.class" "$cache_path/"
    
    # Save metadata
    cat > "$cache_path/metadata.json" << EOF
{
    "source_hash": "$(get_source_hash)",
    "drivers_hash": "$(get_drivers_hash)",
    "created_at": "$(date -Iseconds)",
    "query_runner_version": "1.0"
}
EOF
}

load_from_cache() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")
    echo "$cache_path/QueryRunner.class"
}

cleanup_old_cache() {
    # Remove cache directories older than 7 days
    find "$CACHE_DIR" -maxdepth 1 -type d -mtime +7 -exec rm -rf {} \; 2>/dev/null || true
}

get_classpath_cache_key() {
    # Generate cache key based on drivers directory contents and timestamps
    local drivers_info=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_info=$(find "$DRIVERS_DIR" -name "*.jar" -type f -printf "%p|%T@\n" 2>/dev/null | sort | md5sum | cut -d' ' -f1)
    fi
    echo "classpath_${drivers_info}"
}

get_cached_classpath() {
    local cache_key="$1"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"
    
    if [[ -f "$cache_file" ]]; then
        # Check if cache is still valid (drivers haven't changed)
        local current_key
        current_key=$(get_classpath_cache_key)
        if [[ "$cache_key" == "$current_key" ]]; then
            cat "$cache_file"
            return 0
        fi
    fi
    
    return 1
}

save_classpath_cache() {
    local cache_key="$1"
    local classpath="$2"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"
    echo "$classpath" > "$cache_file"
}

build_classpath() {
    local jar_file="$1"
    local cache_key
    cache_key=$(get_classpath_cache_key)
    
    # Try to get from cache first
    local cached_classpath
    if cached_classpath=$(get_cached_classpath "$cache_key"); then
        echo "$cached_classpath:$jar_file"
        return 0
    fi
    
    # Build classpath from scratch with lazy loading
    local classpath="$jar_file"
    local db_type
    db_type=$(detect_database_type)
    
    if [[ -d "$DRIVERS_DIR" ]]; then
        case "$db_type" in
            "mysql")
                for jar in "$DRIVERS_DIR"/*mysql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "postgresql")
                for jar in "$DRIVERS_DIR"/*postgresql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "oracle")
                for jar in "$DRIVERS_DIR"/*oracle*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlserver")
                for jar in "$DRIVERS_DIR"/*sqlserver*.jar "$DRIVERS_DIR"/*mssql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "db2")
                for jar in "$DRIVERS_DIR"/*db2*.jar "$DRIVERS_DIR"/*jt400*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "h2")
                for jar in "$DRIVERS_DIR"/*h2*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlite")
                for jar in "$DRIVERS_DIR"/*sqlite*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            *)
                # Fallback: include all JARs
                for jar in "$DRIVERS_DIR"/*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
        esac
        
        # Always include SLF4J dependencies if present
        for jar in "$DRIVERS_DIR"/slf4j*.jar; do
            [[ -f "$jar" ]] && classpath="$classpath:$jar"
        done
    fi
    
    # Save to cache
    save_classpath_cache "$cache_key" "$classpath"
    
    echo "$classpath"
}

get_precompiled_class() {
    # Check for pre-compiled QueryRunner.class in script directory
    local precompiled="$SCRIPT_DIR/QueryRunner.class"
    if [[ -f "$precompiled" ]]; then
        # Check if it's compatible with current script
        local script_hash
        script_hash=$(get_source_hash)
        local precompiled_hash_file="$SCRIPT_DIR/.query_runner_hash"
        
        if [[ -f "$precompiled_hash_file" ]]; then
            local stored_hash
            stored_hash=$(cat "$precompiled_hash_file")
            if [[ "$script_hash" == "$stored_hash" ]]; then
                echo "$precompiled"
                return 0
            fi
        fi
    fi
    
    return 1
}

save_precompiled_hash() {
    local script_hash
    script_hash=$(get_source_hash)
    echo "$script_hash" > "$SCRIPT_DIR/.query_runner_hash"
}

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] [QUERY_FILE]

Execute read-only SQL queries using JDBC with autoconfiguration.

Arguments:
    QUERY_FILE    Optional path to file containing SQL query.
                  If not provided, reads query from stdin.

Options:
    -f, --format FORMAT     Output format: text, csv, json, pretty
    -t, --type TYPE         Database type: mysql, postgresql, oracle, sqlserver,
                           db2, h2, sqlite (auto-detect if not specified)
    -h, --host HOST         Database host (overrides .env)
    -p, --port PORT         Database port (overrides .env)
    -d, --database DATABASE Database name (overrides .env)
    -u, --user USER         Database user (overrides .env)
    -P, --password PASSWORD Database password (overrides .env)
    -e, --env-file FILE     Custom environment file (default: .env)
    --drivers-dir DIR       JDBC drivers directory (default: ./drivers)
    --list-drivers          List available database drivers and exit
    --test-connection       Test database connection and exit
    -h, --help              Show this help message

Examples:
    echo "SELECT * FROM users LIMIT 10" | $(basename "$0")
    $(basename "$0") -t mysql query.sql
    $(basename "$0") -f json --host localhost --port 5432 -t postgresql query.sql
    $(basename "$0") --test-connection

Environment:
    Uses .env file for database connection settings.
    Autoconfigures based on DB_TYPE.
    Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite
EOF
    exit 1
}

check_read_only() {
    local query="$1"
    local normalized_query
    normalized_query=$(echo "$query" | tr '[:upper:]' '[:lower:]' | sed 's/--.*$//' | sed 's/\s\+/ /g' | xargs)
    
    # Check for dangerous patterns anywhere in the query
    local dangerous_patterns=(
        "insert "
        "update "
        "delete "
        "drop "
        "create "
        "alter "
        "truncate "
        "exec "
        "execute "
        "grant "
        "revoke "
        "commit "
        "rollback "
        "union "  # Can be used for data extraction
        "load "   # LOAD DATA INFILE
        "copy "   # COPY command in PostgreSQL
        "backup " # BACKUP DATABASE
        "restore " # RESTORE DATABASE
    )
    
    for pattern in "${dangerous_patterns[@]}"; do
        if [[ "$normalized_query" =~ [[:space:]]$pattern ]]; then
            echo "Error: Only read-only queries are allowed. Detected potentially dangerous pattern: $pattern" >&2
            exit 1
        fi
    done
    
    # Check for suspicious comment patterns that might hide malicious code
    if [[ "$normalized_query" =~ [[:space:]]*/\*.*\*/[[:space:]]* ]]; then
        echo "Error: Block comments are not allowed for security reasons" >&2
        exit 1
    fi
    
    # Check for multiple statements (semicolon separation)
    if [[ "$normalized_query" == *";"* ]]; then
        echo "Error: Multiple SQL statements are not allowed" >&2
        exit 1
    fi
    
    # Query must start with a read-only operation
    if [[ ! "$normalized_query" =~ ^[[:space:]]*(select|with|show|describe|explain|pragma)[[:space:]] ]]; then
        echo "Error: Query must start with a read-only operation (SELECT, WITH, SHOW, DESCRIBE, EXPLAIN, PRAGMA)" >&2
        exit 1
    fi
}

detect_database_type() {
    local db_type="${DB_TYPE:-}"
    
    if [[ -n "$db_type" ]]; then
        echo "$db_type"
        return 0
    fi
    
    # Try to detect from JDBC_URL if available
    if [[ -n "${JDBC_URL:-}" ]]; then
        case "$JDBC_URL" in
            *mysql*) echo "mysql"; return 0 ;;
            *postgresql*) echo "postgresql"; return 0 ;;
            *oracle*) echo "oracle"; return 0 ;;
            *sqlserver*) echo "sqlserver"; return 0 ;;
            *db2*) echo "db2"; return 0 ;;
            *h2*) echo "h2"; return 0 ;;
            *sqlite*) echo "sqlite"; return 0 ;;
        esac
    fi
    
    # Try to detect from available drivers
    if [[ -d "$DRIVERS_DIR" ]]; then
        if ls "$DRIVERS_DIR"/*mysql* 1> /dev/null 2>&1; then echo "mysql"; return 0; fi
        if ls "$DRIVERS_DIR"/*postgresql* 1> /dev/null 2>&1; then echo "postgresql"; return 0; fi
        if ls "$DRIVERS_DIR"/*oracle* 1> /dev/null 2>&1; then echo "oracle"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlserver* 1> /dev/null 2>&1; then echo "sqlserver"; return 0; fi
        if ls "$DRIVERS_DIR"/*db2* 1> /dev/null 2>&1; then echo "db2"; return 0; fi
        if ls "$DRIVERS_DIR"/*h2* 1> /dev/null 2>&1; then echo "h2"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlite* 1> /dev/null 2>&1; then echo "sqlite"; return 0; fi
    fi
    
    return 1
}

configure_database() {
    local db_type="$1"
    
    case "$db_type" in
        mysql)
            DB_PORT="${DB_PORT:-3306}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.mysql.cj.jdbc.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mysql-connector-java*.jar}"
            ;;
        postgresql)
            DB_PORT="${DB_PORT:-5432}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.postgresql.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-postgresql*.jar}"
            ;;
        oracle)
            DB_PORT="${DB_PORT:-1521}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-oracle.jdbc.OracleDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:oracle:thin:@${DB_HOST}:${DB_PORT}:${DB_DATABASE}?connectTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-ojdbc*.jar}"
            ;;
        sqlserver)
            DB_PORT="${DB_PORT:-1433}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.microsoft.sqlserver.jdbc.SQLServerDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:sqlserver://${DB_HOST}:${DB_PORT};databaseName=${DB_DATABASE};loginTimeout=${timeout};socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mssql-jdbc*.jar}"
            ;;
        db2)
            DB_PORT="${DB_PORT:-50000}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.ibm.db2.jcc.DB2Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:db2://${DB_HOST}:${DB_PORT}/${DB_DATABASE}:clientProgramName=${timeout};"
            fi
            DRIVER_JAR="${DRIVER_JAR:-db2jcc*.jar jt400*.jar}"
            ;;
        h2)
            DB_PORT="${DB_PORT:-9092}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.h2.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:h2:tcp://${DB_HOST}:${DB_PORT}/${DB_DATABASE};loginTimeout=${timeout}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-h2*.jar}"
            ;;
        sqlite)
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.sqlite.JDBC}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                JDBC_URL="jdbc:sqlite:${DB_DATABASE}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-sqlite-jdbc*.jar}"
            ;;
        *)
            echo "Error: Unsupported database type: $db_type" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
            ;;
    esac
}

find_driver_jar() {
    local driver_pattern="$1"
    local jar_files=()
    
    # Search in drivers directory
    if [[ -d "$DRIVERS_DIR" ]]; then
        for pattern in $driver_pattern; do
            while IFS= read -r -d '' jar; do
                jar_files+=("$jar")
            done < <(find "$DRIVERS_DIR" -name "$pattern" -type f -print0 2>/dev/null)
        done
    fi
    
    # Search in script directory
    while IFS= read -r -d '' jar; do
        jar_files+=("$jar")
    done < <(find "$SCRIPT_DIR" -name "*.jar" -type f -print0 2>/dev/null)
    
    if [[ ${#jar_files[@]} -eq 0 ]]; then
        echo "Error: No JDBC driver found matching pattern: $driver_pattern" >&2
        echo "Please place the appropriate JDBC driver JAR in $DRIVERS_DIR or $SCRIPT_DIR" >&2
        exit 1
    fi
    
    # Return the first match
    echo "${jar_files[0]}"
}

list_drivers() {
    echo "Available database drivers:"
    echo "=========================="
    
    local found_drivers=()
    
    if [[ -d "$DRIVERS_DIR" ]]; then
        while IFS= read -r -d '' jar; do
            local basename
            basename=$(basename "$jar")
            case "$basename" in
                *mysql*) found_drivers+=("MySQL: $basename") ;;
                *postgresql*) found_drivers+=("PostgreSQL: $basename") ;;
                *oracle*) found_drivers+=("Oracle: $basename") ;;
                *sqlserver*|*mssql*) found_drivers+=("SQL Server: $basename") ;;
                *db2*|*jt400*) found_drivers+=("DB2/AS400: $basename") ;;
                *h2*) found_drivers+=("H2: $basename") ;;
                *sqlite*) found_drivers+=("SQLite: $basename") ;;
                *) found_drivers+=("Unknown: $basename") ;;
            esac
        done < <(find "$DRIVERS_DIR" -name "*.jar" -type f -print0 2>/dev/null)
    fi
    
    if [[ ${#found_drivers[@]} -eq 0 ]]; then
        echo "No JDBC drivers found in $DRIVERS_DIR"
        echo "Download drivers and place them in the drivers directory:"
        echo "- MySQL: https://dev.mysql.com/downloads/connector/j/"
        echo "- PostgreSQL: https://jdbc.postgresql.org/download/"
        echo "- Oracle: https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html"
        echo "- SQL Server: https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server"
        echo "- DB2: https://www.ibm.com/support/pages/node/6331129"
        echo "- H2: https://www.h2database.com/html/download.html"
        echo "- SQLite: https://github.com/xerial/sqlite-jdbc/releases"
    else
        printf '%s\n' "${found_drivers[@]}"
    fi
}

test_connection() {
    echo "Testing database connection..." >&2
    echo "Host: ${DB_HOST}" >&2
    echo "Port: ${DB_PORT}" >&2
    echo "Database: ${DB_DATABASE}" >&2
    echo "User: ${DB_USER}" >&2
    echo "URL: ${JDBC_URL}" >&2
    echo "Driver: ${JDBC_DRIVER_CLASS}" >&2
    
    local test_query="SELECT 1"
    execute_query "$test_query" "text" > /dev/null
    echo "Connection successful!" >&2
}

load_env() {
    if [[ ! -f "$ENV_FILE" ]]; then
        echo "Warning: .env file not found at $ENV_FILE" >&2
        echo "You can specify connection details via command line options" >&2
    else
        set -a
        # shellcheck source=/dev/null
        source "$ENV_FILE"
        set +a
    fi
    
    # Override with command line arguments if provided
    DB_HOST="${CLI_HOST:-${DB_HOST:-localhost}}"
    DB_PORT="${CLI_PORT:-${DB_PORT:-}}"
    DB_DATABASE="${CLI_DATABASE:-${DB_DATABASE:-}}"
    DB_USER="${CLI_USER:-${DB_USER:-}}"
    DB_PASSWORD="${CLI_PASSWORD:-${DB_PASSWORD:-}}"
    
# Auto-detect or use specified database type
    local db_type
    if [[ -n "${CLI_TYPE:-}" ]]; then
        db_type="$CLI_TYPE"
    else
        if ! db_type=$(detect_database_type); then
            echo "Error: Could not auto-detect database type" >&2
            echo "Please specify DB_TYPE in .env or use -t option" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
        fi
    fi
    
    echo "Using database type: $db_type" >&2
    configure_database "$db_type"
    
    # Find the appropriate driver JAR
    JAR_FILE=$(find_driver_jar "$DRIVER_JAR")
    echo "Using driver: $(basename "$JAR_FILE")" >&2
    
    # Validate required variables
    if [[ "$db_type" != "sqlite" ]]; then
        required_vars=("DB_HOST" "DB_USER" "DB_PASSWORD")
        for var in "${required_vars[@]}"; do
            if [[ -z "${!var:-}" ]]; then
                echo "Error: Required environment variable $var is not set" >&2
                exit 1
            fi
        done
    fi
    
    if [[ -z "${DB_DATABASE:-}" && "$db_type" != "sqlite" ]]; then
        echo "Error: Database name is required" >&2
        exit 1
    fi
}

execute_query() {
    local query="$1"
    local format="$2"
    local temp_dir temp_java_file cache_key cached_class_file
    
    check_read_only "$query"
    
    # Check for pre-compiled class first
    local precompiled_class
    local use_precompiled=false
    
    if precompiled_class=$(get_precompiled_class); then
        temp_dir=$(dirname "$precompiled_class")
        use_precompiled=true
    else
        # Initialize cache and check for valid cached compilation
        init_cache
        cleanup_old_cache
        cache_key=$(get_cache_key)
        
        if is_cache_valid "$cache_key"; then
            cached_class_file=$(load_from_cache "$cache_key")
            temp_dir=$(dirname "$cached_class_file")
        else
            # Need to compile
            temp_dir=$(mktemp -d)
            temp_java_file="$temp_dir/QueryRunner.java"
            
            cat > "$temp_java_file" << EOF
import java.sql.*;
import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.io.StringWriter;

public class QueryRunner {
    public static void main(String[] args) {
        String url = System.getenv("JDBC_URL");
        String user = System.getenv("DB_USER");
        String password = System.getenv("DB_PASSWORD");
        String driverClass = System.getenv("JDBC_DRIVER_CLASS");
        String format = System.getenv("OUTPUT_FORMAT");
        if (format == null) format = "text";
        
        try {
            Class.forName(driverClass);
            
            StringBuilder queryBuilder = new StringBuilder();
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNextLine()) {
                queryBuilder.append(scanner.nextLine()).append("\n");
            }
            scanner.close();
            
            String query = queryBuilder.toString().trim();
            if (query.isEmpty()) {
                System.err.println("Error: Empty query");
                System.exit(1);
            }
            
            try (Connection conn = DriverManager.getConnection(url, user, password);
                 Statement stmt = conn.createStatement();
                  ResultSet rs = stmt.executeQuery(query)) {
                
                ResultSetMetaData metaData = rs.getMetaData();
                int columnCount = metaData.getColumnCount();
                List<String> columnNames = new ArrayList<>();
                for (int i = 1; i <= columnCount; i++) {
                    columnNames.add(metaData.getColumnName(i));
                }
                
                switch (format) {
                    case "json":
                        outputJsonStream(columnNames, rs);
                        break;
                    case "csv":
                        outputCsvStream(columnNames, rs);
                        break;
                    case "pretty":
                        // Pretty format needs two passes, so collect data first
                        List<Map<String, Object>> rows = new ArrayList<>();
                        while (rs.next()) {
                            Map<String, Object> row = new HashMap<>();
                            for (int i = 1; i <= columnCount; i++) {
                                row.put(columnNames.get(i-1), rs.getObject(i));
                            }
                            rows.add(row);
                        }
                        outputPretty(columnNames, rows);
                        break;
                    case "text":
                    default:
                        outputTextStream(columnNames, rs);
                        break;
                }
                
            } catch (SQLException e) {
                System.err.println("SQL Error: " + e.getMessage());
                System.err.println("SQL State: " + e.getSQLState());
                System.err.println("Error Code: " + e.getErrorCode());
                System.exit(1);
            }
            
        } catch (ClassNotFoundException e) {
            System.err.println("Error: JDBC driver not found: " + e.getMessage());
            System.exit(1);
        }
    }
    
    private static String escapeJson(String str) {
        if (str == null) return null;
        return str.replace("\\", "\\\\").replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
    }
    
    private static String repeatString(String str, int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {
            sb.append(str);
        }
        return sb.toString();
    }
    
    private static void outputJsonStream(List<String> columnNames, ResultSet rs) throws SQLException {
        System.out.print("[");
        boolean first = true;
        while (rs.next()) {
            if (!first) System.out.print(",");
            first = false;
            System.out.print("{");
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                System.out.print("\"" + escapeJson(columnNames.get(i)) + "\":");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("null");
                } else if (value instanceof Number || value instanceof Boolean) {
                    System.out.print(value.toString());
                } else {
                    System.out.print("\"" + escapeJson(value.toString()) + "\"");
                }
            }
            System.out.print("}");
        }
        System.out.println("]");
    }
    
    private static void outputCsvStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print(",");
            System.out.print("\"" + columnNames.get(i).replace("\"", "\"\"") + "\"");
        }
        System.out.println();
        
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("");
                } else {
                    String strValue = value.toString();
                    System.out.print("\"" + strValue.replace("\"", "\"\"") + "\"");
                }
            }
            System.out.println();
        }
    }
    
    private static void outputPrettyStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // First pass: calculate column widths
        int[] maxWidths = new int[columnNames.size()];
        for (int i = 0; i < columnNames.size(); i++) {
            maxWidths[i] = columnNames.get(i).length();
        }
        
        // Save current position to return later
        rs.beforeFirst();
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = rs.getObject(i + 1);
                String strValue = value != null ? value.toString() : "NULL";
                maxWidths[i] = Math.max(maxWidths[i], strValue.length());
            }
        }
        
        // Reset to beginning for second pass
        rs.beforeFirst();
        
        // Output header and separator
        String separator = "+";
        for (int width : maxWidths) {
            separator += repeatString("-", width + 2) + "+";
        }
        System.out.println(separator);
        
        System.out.print("|");
        for (int i = 0; i < columnNames.size(); i++) {
            System.out.print(" " + String.format("%-" + maxWidths[i] + "s", columnNames.get(i)) + " |");
        }
        System.out.println();
        System.out.println(separator);
        
        // Stream rows with formatting
        while (rs.next()) {
            System.out.print("|");
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = rs.getObject(i + 1);
                String strValue = value != null ? value.toString() : "NULL";
                System.out.print(" " + String.format("%-" + maxWidths[i] + "s", strValue) + " |");
            }
            System.out.println();
        }
        System.out.println(separator);
    }
    
    private static void outputTextStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print("\t");
            System.out.print(columnNames.get(i));
        }
        System.out.println();
        
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print("\t");
                Object value = rs.getObject(i + 1);
                System.out.print(value != null ? value.toString() : "NULL");
            }
            System.out.println();
        }
    }
    
    private static void outputPretty(List<String> columnNames, List<Map<String, Object>> rows) {
        int[] maxWidths = new int[columnNames.size()];
        for (int i = 0; i < columnNames.size(); i++) {
            maxWidths[i] = columnNames.get(i).length();
        }
        
        for (Map<String, Object> row : rows) {
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                maxWidths[i] = Math.max(maxWidths[i], strValue.length());
            }
        }
        
        String separator = "+";
        for (int width : maxWidths) {
            separator += repeatString("-", width + 2) + "+";
        }
        System.out.println(separator);
        
        System.out.print("|");
        for (int i = 0; i < columnNames.size(); i++) {
            System.out.print(" " + String.format("%-" + maxWidths[i] + "s", columnNames.get(i)) + " |");
        }
        System.out.println();
        System.out.println(separator);
        
        for (Map<String, Object> row : rows) {
            System.out.print("|");
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                System.out.print(" " + String.format("%-" + maxWidths[i] + "s", strValue) + " |");
            }
            System.out.println();
        }
        System.out.println(separator);
    }
}
EOF
        
        if ! javac_output=$(javac "$temp_java_file" 2>&1); then
            echo "Error: Failed to compile Java code" >&2
            echo "Compilation error details:" >&2
            echo "$javac_output" >&2
            rm -rf "$temp_dir"
            exit 1
        fi
        
        # Save to cache for future use
        save_to_cache "$cache_key" "$temp_dir"
        
        # Set trap to cleanup temp directory only for fresh compilations
        trap 'rm -rf "${temp_dir:-}"' EXIT
    fi
    fi
    
    local classpath
    classpath=$(build_classpath "$JAR_FILE")
    export OUTPUT_FORMAT="$format" JDBC_URL JDBC_DRIVER_CLASS DB_USER DB_PASSWORD
    echo -n "$query" | java --enable-native-access=ALL-UNNAMED -cp "$classpath:$temp_dir" QueryRunner
}

interactive_mode() {
    local db_type
    db_type=$(detect_database_type)
    echo "Query Runner - Interactive Mode" >&2
    echo "Database Type: $db_type" >&2
    if [[ "$db_type" != "sqlite" ]]; then
        echo "Connected to: ${DB_DATABASE}@${DB_HOST}:${DB_PORT}" >&2
    else
        echo "Connected to: ${DB_DATABASE}" >&2
    fi
    echo "Enter SQL query (empty line to execute, Ctrl+C to exit):" >&2
    
    while true; do
        echo -n "> " >&2
        local query=""
        local line
        
        while IFS= read -r line; do
            if [[ -z "$line" ]]; then
                break
            fi
            query+="$line"$'\n'
            echo -n "> " >&2
        done
        
        if [[ -z "$query" ]]; then
            echo "Goodbye!" >&2
            exit 0
        fi
        
        echo >&2
        execute_query "$query" "text"
        echo >&2
    done
}

main() {
    local format="text"
    local query_file=""
    local list_drivers_flag=false
    local test_connection_flag=false
    local original_arg_count=$#
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--format)
                format="$2"
                shift 2
                ;;
            -t|--type)
                CLI_TYPE="$2"
                shift 2
                ;;
            -h|--host)
                CLI_HOST="$2"
                shift 2
                ;;
            -p|--port)
                CLI_PORT="$2"
                shift 2
                ;;
            -d|--database)
                CLI_DATABASE="$2"
                shift 2
                ;;
            -u|--user)
                CLI_USER="$2"
                shift 2
                ;;
            -P|--password)
                CLI_PASSWORD="$2"
                shift 2
                ;;
            -e|--env-file)
                ENV_FILE="$2"
                shift 2
                ;;
            --drivers-dir)
                DRIVERS_DIR="$2"
                shift 2
                ;;
            --list-drivers)
                list_drivers_flag=true
                shift
                ;;
            --test-connection)
                test_connection_flag=true
                shift
                ;;
            --help)
                usage
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                usage
                ;;
            *)
                if [[ -n "$query_file" ]]; then
                    echo "Error: Multiple query files specified" >&2
                    usage
                fi
                query_file="$1"
                shift
                ;;
        esac
    done
    
    # Show help if no arguments provided and no special flags set
    if [[ $original_arg_count -eq 0 && "$list_drivers_flag" == false && "$test_connection_flag" == false ]]; then
        usage
    fi
    
    case "$format" in
        text|csv|json|pretty)
            ;;
        *)
            echo "Error: Invalid format '$format'. Must be one of: text, csv, json, pretty" >&2
            exit 1
            ;;
    esac
    
    # Handle special flags
    if [[ "$list_drivers_flag" == true ]]; then
        list_drivers
        exit 0
    fi
    
    # Load environment and configure database
    load_env
    
    if [[ "$test_connection_flag" == true ]]; then
        test_connection
        exit 0
    fi
    
    # Interactive mode if no query file and stdin is a terminal
    if [[ $# -eq 0 && -z "$query_file" && -t 0 ]]; then
        interactive_mode
        exit 0
    fi
    
    local query=""
    
    if [[ -z "$query_file" ]]; then
        if [[ -t 0 ]]; then
            echo "Reading query from stdin (Ctrl+D to finish):" >&2
        fi
        query=$(cat)
    else
        if [[ ! -f "$query_file" ]]; then
            echo "Error: Query file not found: $query_file" >&2
            exit 1
        fi
        query=$(cat "$query_file")
    fi
    
    if [[ -z "$query" ]]; then
        if [[ $# -eq 0 ]]; then
            usage
        else
            echo "Error: Empty query provided" >&2
            exit 1
        fi
    fi
    
    execute_query "$query" "$format"
}

main "$@"