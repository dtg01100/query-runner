#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"
DRIVERS_DIR="$SCRIPT_DIR/drivers"
CACHE_DIR="$HOME/.query_runner/cache"

# Java binaries
JAVA_BIN=""
JAVAC_BIN=""

# Default debug flag from environment variable - CLI can override
QUERY_RUNNER_DEBUG="${QUERY_RUNNER_DEBUG:-0}"

# Cache management functions
init_cache() {
    [[ -d "$CACHE_DIR" ]] || mkdir -p "$CACHE_DIR"
}

get_source_hash() {
    # Hash of the query_runner script itself
    md5sum "$0" | cut -d' ' -f1
}

get_drivers_hash() {
    # Hash of all JAR files in drivers directory
    local drivers_hash=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_hash=$(find "$DRIVERS_DIR" -name "*.jar" -type f -exec md5sum {} \; | sort | md5sum | cut -d' ' -f1)
    fi
    echo "$drivers_hash"
}

get_cache_key() {
    local source_hash
    local drivers_hash
    source_hash=$(get_source_hash)
    drivers_hash=$(get_drivers_hash)
    echo "${source_hash}_${drivers_hash}"
}

get_cache_dir_for_key() {
    local cache_key="$1"
    echo "$CACHE_DIR/$cache_key"
}

# Debug helper: echo messages only when DEBUG is enabled
debug() {
    local debug_val="${DEBUG:-$QUERY_RUNNER_DEBUG}"
    if [[ "$debug_val" != "0" && "$debug_val" != "false" ]]; then
        echo "DEBUG: $*" >&2
    fi
}

# Enhanced path validation with stricter security controls
validate_path_input() {
    local path="$1"
    local context="$2"  # "query", "database", "env", etc.
    
    # Reject null bytes and control characters
    if printf '%s' "$path" | grep -qP '\x00|[\x01-\x1F\x7F]'; then
        echo "Error: Invalid control characters in $context path" >&2
        exit 1
    fi
    
    # Length validation
    if [[ ${#path} -gt 4096 ]]; then
        echo "Error: $context path too long (maximum 4096 characters)" >&2
        exit 1
    fi
    
    # Check for suspicious patterns
    case "$context" in
        "query")
            # Query files should not contain certain patterns
            if [[ "$path" =~ \.\./ ]] || [[ "$path" =~ ~.*[/.].*\. ]]; then
                echo "Error: Invalid query file path" >&2
                exit 1
            fi
            ;;
        "database")
            # Database paths have specific restrictions
            if [[ "$path" =~ \.\./ ]] && [[ ! "$path" =~ ^/ ]]; then
                echo "Error: Invalid database path" >&2
                exit 1
            fi
            ;;
        "env"|"drivers")
            # Environment and drivers paths
            if [[ "$path" =~ \.\./ ]] && [[ ! "$path" =~ ^/ ]]; then
                echo "Error: Invalid $context path" >&2
                exit 1
            fi
            ;;
    esac
}

# Enhanced normalize_query_file_path with better security
normalize_query_file_path() {
    local path="$1"
    
    # Validate input first
    validate_path_input "$path" "query"
    
    # Reject CR and NUL characters explicitly, then trim whitespace
    # Detect NUL bytes if `od` is available
    if command -v od >/dev/null 2>&1; then
        if printf '%s' "$path" | od -An -t x1 -v | grep -q -E '(^| )00($| )'; then
            return 1
        fi
    else
        # Fallback: detect control characters including carriage return via awk
        if printf '%s' "$path" | awk '/[[:cntrl:]]/ { exit 1 }'; then
            :
        else
            return 1
        fi
    fi
    
    # Reject any carriage returns or tabs or newline characters explicitly
    case "$path" in
        *$'\r'*|*$'\n'*|*$'\t'*)
            return 1
            ;;
    esac
    
    # Trim leading/trailing whitespace (spaces and tabs)
    path=$(printf '%s' "$path" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

    # Reject paths containing newline/tab (weird terminals)
    case "$path" in
        *$'\n'*|*$'\t'*)
            return 1
            ;;
    esac

    # Expand ~ at beginning with validation
    if [[ "$path" == ~* ]]; then
        # expand ~ and ~user only for simple forms
        if [[ "$path" =~ ^~[a-zA-Z0-9_\-]+(/.*)?$ ]]; then
            # shell will expand ~user only when not quoted, so fallback to path as-is (no expansion)
            true
        else
            # Validate that HOME exists and is accessible
            if [[ -z "$HOME" ]] || [[ ! -d "$HOME" ]]; then
                return 1
            fi
            path="${path/#\~/$HOME}"
        fi
    fi

    # Fast path: '-' means stdin
    if [[ "$path" == "-" ]]; then
        printf '%s' "-"
        return 0
    fi

    # Security check: prevent access to sensitive directories
    case "$path" in
        /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
            echo "Error: Access to system directories is not allowed" >&2
            return 1
            ;;
    esac

    # If path exists, canonicalize; otherwise return path as provided
    if [[ -e "$path" ]]; then
        if command -v realpath >/dev/null 2>&1; then
            local canonical
            canonical=$(realpath -m -- "$path" 2>/dev/null || true)
            if [[ -n "$canonical" ]]; then
                # Additional security check: ensure we're not escaping allowed directories
                case "$canonical" in
                    /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
                        echo "Error: Access to system directories is not allowed" >&2
                        return 1
                        ;;
                    *)
                        printf '%s' "$canonical"
                        return 0
                        ;;
                esac
            fi
        fi
        if command -v readlink >/dev/null 2>&1; then
            local canonical2
            canonical2=$(readlink -f -- "$path" 2>/dev/null || true)
            if [[ -n "$canonical2" ]]; then
                # Additional security check for readlink result
                case "$canonical2" in
                    /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
                        echo "Error: Access to system directories is not allowed" >&2
                        return 1
                        ;;
                    *)
                        printf '%s' "$canonical2"
                        return 0
                        ;;
                esac
            fi
        fi
        # Fallback to absolute via cd
        local dir base abs
        dir=$(dirname -- "$path")
        base=$(basename -- "$path")
        if cd -- "$dir" 2>/dev/null; then
            abs="$PWD/$base"
            # Security check for fallback result
            case "$abs" in
                /etc/*|/proc/*|/sys/*|/dev/*|/boot/*|/root/*|/bin/*|/sbin/*|/lib/*|/lib64/*)
                    echo "Error: Access to system directories is not allowed" >&2
                    return 1
                    ;;
                *)
                    printf '%s' "$abs"
                    return 0
                    ;;
            esac
        fi
    fi

    # If not found or canonicalization fails, return the trimmed path (may be relative)
    # But validate it doesn't contain dangerous patterns
    case "$path" in
        *../*)
            echo "Error: Path traversal attempt detected" >&2
            return 1
            ;;
        *)
            printf '%s' "$path"
            return 0
            ;;
    esac
}

# Generic wrapper for normalizing filesystem paths that can be used for both
# query files and database files. Keep a separate name for clarity.
normalize_fs_path() {
    local p
    p=$(normalize_query_file_path "$1") || return 1
    printf '%s' "$p"
}

is_cache_valid() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")

    [[ -d "$cache_path" ]] || return 1
    [[ -f "$cache_path/QueryRunner.class" ]] || return 1
    [[ -f "$cache_path/metadata.json" ]] || return 1

    # Check if cache is not too old (24 hours)
    local cache_age
    cache_age=$(find "$cache_path" -maxdepth 1 -type f -mtime +1 | wc -l)
    [[ $cache_age -eq 0 ]] || return 1

    return 0
}

save_to_cache() {
    local cache_key="$1"
    local temp_dir="$2"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")

    # Create cache directory
    mkdir -p "$cache_path"

    # Copy compiled class file
    cp "$temp_dir/QueryRunner.class" "$cache_path/"

    # Save metadata
    cat > "$cache_path/metadata.json" << 'EOF'
{
    "source_hash": "$(get_source_hash)",
    "drivers_hash": "$(get_drivers_hash)",
    "created_at": "$(date -Iseconds)",
    "query_runner_version": "1.0"
}
EOF
}

load_from_cache() {
    local cache_key="$1"
    local cache_path
    cache_path=$(get_cache_dir_for_key "$cache_key")
    echo "$cache_path/QueryRunner.class"
}

cleanup_old_cache() {
    # Remove cache directories older than 7 days
    find "$CACHE_DIR" -maxdepth 1 -type d -mtime +7 -exec rm -rf {} \; 2>/dev/null || true
}

check_java_availability() {
    if command -v java >/dev/null 2>&1 && command -v javac >/dev/null 2>&1; then
        JAVA_BIN=$(command -v java)
        JAVAC_BIN=$(command -v javac)
        return 0
    fi
    return 1
}

# Enhanced error handling with information leakage prevention
safe_exit() {
    local exit_code="$1"
    local message="$2"
    local sensitive_context="$3"
    
    # Sanitize error messages to prevent information leakage
    if [[ -n "$message" ]]; then
        # Remove potentially sensitive information from error messages
        message=$(echo "$message" | \
            sed -E 's/(password|passwd|pwd)[[:space:]]*[:=][[:space:]]*[^[:space:],;]+/\1=******/gi' | \
            sed -E 's/(user|username|uid)[[:space:]]*[:=][[:space:]]*[^[:space:],;]+/\1=******/gi' | \
            sed -E 's/(host|server|hostname)[[:space:]]*[:=][[:space:]]*[^[:space:],;]+/\1=******/gi' | \
            sed -E 's/jdbc:[^[:space:]]+/jdbc:*** CONNECTION_STRING ***/gi' | \
            sed -E 's/(localhost|127\.0\.0\.1|::1)/***HOST***/gi')
        
        # Only show detailed error messages in debug mode
        if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
            # In non-debug mode, show generic messages
            case "$sensitive_context" in
                "database"|"connection"|"jdbc")
                    echo "Error: Database connection failed" >&2
                    ;;
                "query"|"sql")
                    echo "Error: Query execution failed" >&2
                    ;;
                "file"|"path")
                    echo "Error: File operation failed" >&2
                    ;;
                "input"|"validation")
                    echo "Error: Input validation failed" >&2
                    ;;
                *)
                    echo "Error: Operation failed" >&2
                    ;;
            esac
        else
            # In debug mode, show sanitized but more detailed messages
            echo "Error: $message" >&2
        fi
    fi
    
    exit "$exit_code"
}

# Enhanced error handling function that prevents information leakage
handle_error() {
    local error_type="$1"
    local error_message="$2"
    local exit_code="${3:-1}"
    
    case "$error_type" in
        "database_connection")
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: Unable to connect to database" >&2
            else
                echo "Error: Database connection failed: $error_message" >&2
            fi
            ;;
        "sql_execution")
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: SQL query execution failed" >&2
            else
                echo "Error: SQL execution failed: $error_message" >&2
            fi
            ;;
        "input_validation")
            echo "Error: Input validation failed: $error_message" >&2
            ;;
        "file_access")
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: File access denied" >&2
            else
                echo "Error: File operation failed: $error_message" >&2
            fi
            ;;
        "security_violation")
            echo "Error: Security policy violation: $error_message" >&2
            ;;
        *)
            if [[ "${DEBUG:-0}" != "1" && "${QUERY_RUNNER_DEBUG:-0}" != "1" ]]; then
                echo "Error: Operation failed" >&2
            else
                echo "Error: $error_message" >&2
            fi
            ;;
    esac
    
    exit "$exit_code"
}

# Replace existing error handling with secure versions
download_standalone_jdk() {
    local java_version="21"
    local java_url="https://api.adoptium.net/v3/binary/latest/${java_version}/ga/linux/x64/jdk/hotspot/normal/adoptium"
    local java_archive="$CACHE_DIR/jdk.tar.gz"
    local java_dir="$CACHE_DIR/jdk"

    if [[ ! -d "$java_dir" ]]; then
        echo "Java is not found on your system." >&2
        read -p "Do you want to download a standalone JDK? (y/n) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            handle_error "dependency" "Java is required to run this script" 1
        fi

        echo "Downloading standalone JDK..." >&2
        if ! curl -L -o "$java_archive" "$java_url" 2>/dev/null; then
            handle_error "download" "Failed to download JDK from $java_url" 1
        fi
        mkdir -p "$java_dir"
        if ! tar -xzf "$java_archive" -C "$java_dir" --strip-components=1 2>/dev/null; then
            handle_error "extract" "Failed to extract JDK archive" 1
        fi
        rm -f "$java_archive"
    fi

    JAVA_BIN="$java_dir/bin/java"
    JAVAC_BIN="$java_dir/bin/javac"

    # Verify the downloaded Java works
    if ! "$JAVA_BIN" -version >/dev/null 2>&1 || ! "$JAVAC_BIN" -version >/dev/null 2>&1; then
        handle_error "validation" "Downloaded JDK is not functional" 1
    fi
}

get_classpath_cache_key() {
    # Generate cache key based on drivers directory contents and timestamps
    local drivers_info=""
    if [[ -d "$DRIVERS_DIR" ]]; then
        drivers_info=$(find "$DRIVERS_DIR" -name "*.jar" -type f -printf "%p|%T@\n" 2>/dev/null | sort | md5sum | cut -d' ' -f1)
    fi
    echo "classpath_${drivers_info}"
}

get_cached_classpath() {
    local cache_key="$1"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"

    if [[ -f "$cache_file" ]]; then
        # Check if cache is still valid (drivers haven't changed)
        local current_key
        current_key=$(get_classpath_cache_key)
        if [[ "$cache_key" == "$current_key" ]]; then
            debug "Using cached classpath file: $cache_file"
            cat "$cache_file"
            return 0
        fi
    fi

    return 1
}

save_classpath_cache() {
    local cache_key="$1"
    local classpath="$2"
    local cache_file="$CACHE_DIR/${cache_key}.classpath"
    echo "$classpath" > "$cache_file"
}

build_classpath() {
    local jar_file="$1"
    local cache_key
    cache_key=$(get_classpath_cache_key)

    # Try to get from cache first
    local cached_classpath
    if cached_classpath=$(get_cached_classpath "$cache_key"); then
        debug "Using cached classpath: $cached_classpath"
        echo "$cached_classpath:$jar_file"
        return 0
    fi

    # Build classpath from scratch with lazy loading
    local classpath="$jar_file"
    local db_type
    db_type=$(detect_database_type)

    if [[ -d "$DRIVERS_DIR" ]]; then
        case "$db_type" in
            "mysql")
                for jar in "$DRIVERS_DIR"/*mysql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "postgresql")
                for jar in "$DRIVERS_DIR"/*postgresql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "oracle")
                for jar in "$DRIVERS_DIR"/*oracle*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlserver")
                for jar in "$DRIVERS_DIR"/*sqlserver*.jar "$DRIVERS_DIR"/*mssql*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "db2")
                for jar in "$DRIVERS_DIR"/*db2*.jar "$DRIVERS_DIR"/*jt400*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "h2")
                for jar in "$DRIVERS_DIR"/*h2*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            "sqlite")
                for jar in "$DRIVERS_DIR"/*sqlite*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
            *)
                # Fallback: include all JARs
                for jar in "$DRIVERS_DIR"/*.jar; do
                    [[ -f "$jar" ]] && classpath="$classpath:$jar"
                done
                ;;
        esac

        # Always include SLF4J dependencies if present
        for jar in "$DRIVERS_DIR"/slf4j*.jar; do
            [[ -f "$jar" ]] && classpath="$classpath:$jar"
        done
    fi

    # Save to cache
    save_classpath_cache "$cache_key" "$classpath"

    echo "$classpath"
}

get_precompiled_class() {
    # Check for pre-compiled QueryRunner.class in script directory
    local precompiled="$SCRIPT_DIR/QueryRunner.class"
    if [[ -f "$precompiled" ]]; then
        # Check if it's compatible with current script
        local script_hash
        script_hash=$(get_source_hash)
        local precompiled_hash_file="$SCRIPT_DIR/.query_runner_hash"

        if [[ -f "$precompiled_hash_file" ]]; then
            local stored_hash
            stored_hash=$(cat "$precompiled_hash_file")
            if [[ "$script_hash" == "$stored_hash" ]]; then
                echo "$precompiled"
                return 0
            fi
        fi
    fi

    return 1
}

save_precompiled_hash() {
    local script_hash
    script_hash=$(get_source_hash)
    echo "$script_hash" > "$SCRIPT_DIR/.query_runner_hash"
}

usage() {
    cat << 'EOF'
Usage: $(basename "$0") [OPTIONS] [QUERY_FILE]

Execute read-only SQL queries using JDBC with autoconfiguration.

Arguments:
    QUERY_FILE    Optional path to file containing SQL query.
                  If not provided, reads query from stdin.

Options:
    -f, --format FORMAT     Output format: text, csv, json, pretty
    -t, --type TYPE         Database type: mysql, postgresql, oracle, sqlserver,
                           db2, h2, sqlite (auto-detect if not specified)
    -h, --host HOST         Database host (overrides .env)
    -p, --port PORT         Database port (overrides .env)
    -d, --database DATABASE Database name (overrides .env)
    -u, --user USER         Database user (overrides .env)
    -P, --password PASSWORD Database password (overrides .env)
-e, --env-file FILE     Custom environment file (default: .env)
     --drivers-dir DIR       JDBC drivers directory (default: ./drivers)
     --list-drivers          List available database drivers and exit
     --test-connection       Test database connection and exit
     -v, --verbose           Enable verbose debug output (same as QUERY_RUNNER_DEBUG=1)
     --debug                 Alias for --verbose
     --download-driver TYPE  Download JDBC driver for TYPE (mysql, postgresql, h2, sqlite, sqlserver)
      --daemon               Enable daemon mode (auto-start if not running)
      --no-daemon            Disable daemon mode, use single-query
      --daemon-start         Start the daemon process
      --daemon-stop          Stop the daemon process
      --daemon-restart       Restart the daemon process
      --daemon-status        Check daemon status
      --allow-union-tables TABLES  Comma-separated list of tables allowed in UNION queries
     -h, --help              Show this help message
    --                      End of options; next argument is interpreted as the query file (even if it starts with '-').

Examples:
    echo "SELECT * FROM users LIMIT 10" | $(basename "$0")
    $(basename "$0") -t mysql query.sql
    $(basename "$0") -f json --host localhost --port 5432 -t postgresql query.sql
    $(basename "$0") --test-connection

Environment:
    Uses .env file for database connection settings.
    Autoconfigures based on DB_TYPE.
    Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite
EOF
    exit 1
}

# Enhanced UNION safety detection with better pattern matching
check_union_safety() {
    local query="$1"
    local normalized_query
    local union_pattern_detected=false
    
    # Normalize query: lowercase, remove comments, collapse whitespace
    normalized_query=$(echo "$query" | tr '[:upper:]' '[:lower:]' | sed 's/--.*$//' | sed 's/\/\*.*\*\///g' | sed 's/\s\+/ /g' | xargs)

    debug "Checking UNION safety for normalized query: $normalized_query"

    # Allow UNION in safe contexts:
    # 1. WITH clauses (CTEs) - safe self-contained operations
    # 2. UNION ALL within same table - safe for data deduplication
    # 3. Explicitly allowed by user flag
    # 4. Subqueries that are clearly contained

    # Check for UNION in CTE context (safe)
    if [[ "$normalized_query" =~ with[[:space:]]+.*[[:space:]]+union[[:space:]]+(all[[:space:]]+)?select ]]; then
        debug "Allowing UNION in CTE context"
        return 0  # Allow UNION and UNION ALL in CTEs
    fi

    # Check for UNION ALL (safer than UNION DISTINCT)
    if [[ "$normalized_query" =~ union[[:space:]]+all[[:space:]]+select ]]; then
        # Still need to validate the tables involved
        debug "UNION ALL detected, checking table safety"
        union_pattern_detected=true
    fi

    # Check for basic UNION (more risky)
    if [[ "$normalized_query" =~ [^a-zA-Z0-9_]union[^a-zA-Z0-9_].*select ]]; then
        debug "Basic UNION detected, checking table safety"
        union_pattern_detected=true
    fi

    # If we detected a UNION pattern, do deeper analysis
    if [[ "$union_pattern_detected" == true ]]; then
        # Extract table names from the query for analysis
        local tables_in_query=()
        
        # Pattern to extract table names from FROM and JOIN clauses
        # This is a simplified extraction - real-world queries can be more complex
        while IFS= read -r table_name; do
            if [[ -n "$table_name" ]]; then
                # Clean up the table name
                table_name=$(echo "$table_name" | sed 's/[`,;().]*//g' | xargs)
                if [[ -n "$table_name" && ! "$table_name" =~ ^(select|from|join|where|and|or|not|in|null|true|false|as|on|using|group|order|limit|offset|union|intersect|except|with)$ ]]; then
                    tables_in_query+=("$table_name")
                fi
            fi
        done < <(echo "$normalized_query" | grep -oE 'from[[:space:]]+[a-zA-Z_][a-zA-Z0-9_]*|join[[:space:]]+[a-zA-Z_][a-zA-Z0-9_]*' | sed 's/.*[[:space:]]//' || true)

        debug "Extracted tables from query: ${tables_in_query[*]}"

        # Check for UNION between same table (safe)
        if [[ ${#tables_in_query[@]} -eq 2 ]] && [[ "${tables_in_query[0]}" == "${tables_in_query[1]}" ]]; then
            debug "Allowing UNION within same table: ${tables_in_query[0]}"
            return 0  # Allow UNION within same table
        fi

        # Check for UNION between multiple different tables (risky)
        if [[ ${#tables_in_query[@]} -gt 1 ]]; then
            local unique_tables=($(printf '%s\n' "${tables_in_query[@]}" | sort -u))
            if [[ ${#unique_tables[@]} -gt 1 ]]; then
                debug "Multiple different tables detected in UNION: ${unique_tables[*]}"
                
                # Check for explicit whitelist flag
                if [[ -n "${ALLOW_UNION_TABLES:-}" ]]; then
                    local allowed_tables
                    IFS=',' read -ra allowed_tables <<< "$ALLOW_UNION_TABLES"
                    local all_allowed=true
                    
                    for table in "${unique_tables[@]}"; do
                        local table_allowed=false
                        for allowed_table in "${allowed_tables[@]}"; do
                            allowed_table=$(echo "$allowed_table" | xargs)  # trim whitespace
                            if [[ "$table" == "$allowed_table" ]]; then
                                table_allowed=true
                                break
                            fi
                        done
                        if [[ "$table_allowed" == false ]]; then
                            all_allowed=false
                            break
                        fi
                    done
                    
                    if [[ "$all_allowed" == true ]]; then
                        debug "All tables in UNION are whitelisted: $ALLOW_UNION_TABLES"
                        return 0  # Allow UNION for whitelisted tables
                    else
                        debug "Some tables not in whitelist: allowed=$ALLOW_UNION_TABLES, found=${unique_tables[*]}"
                    fi
                fi
                
                # If we reach here, the UNION is not allowed
                echo "Error: UNION queries combining data from multiple different tables are not allowed by default." >&2
                echo "Found tables: ${unique_tables[*]}" >&2
                echo "For safe UNION operations, use:" >&2
                echo "  1. UNION ALL with the same table" >&2
                echo "  2. UNION in WITH clauses (CTEs)" >&2
                echo "  3. --allow-union-tables=table1,table2 flag for trusted tables" >&2
                echo "  4. Ensure all tables in the UNION are explicitly whitelisted" >&2
                exit 1
            fi
        fi

        # Check for complex subquery patterns that might be trying to bypass detection
        if [[ "$normalized_query" =~ \([[:space:]]*select.*union ]] || [[ "$normalized_query" =~ select.*\(.*union ]]; then
            debug "Complex subquery with UNION detected, performing additional validation"
            
            # Count the number of UNION occurrences
            local union_count=$(echo "$normalized_query" | grep -o "union" | wc -l)
            if [[ $union_count -gt 1 ]]; then
                echo "Error: Multiple UNION operations detected - this is not allowed for security reasons." >&2
                exit 1
            fi
        fi
    fi

    # If we haven't returned by now, the UNION pattern is not safe
    echo "Error: UNION queries are not allowed by default due to security concerns." >&2
    echo "For safe UNION operations, use:" >&2
    echo "  1. UNION ALL with the same table" >&2
    echo "  2. UNION in WITH clauses (CTEs)" >&2
    echo "  3. --allow-union-tables=table1,table2 flag for trusted tables" >&2
    exit 1
}

# Enhanced query normalization with better error handling
normalize_query_content() {
    local query="$1"
    local normalized_query
    
    # Normalize query: lowercase, remove comments, collapse whitespace
    # Use perl for more robust processing that handles edge cases
    if ! normalized_query=$(echo "$query" | perl -ne 'print lc' 2>/dev/null); then
        echo "Error: Failed to normalize query content" >&2
        echo "The query contains invalid characters or formatting issues." >&2
        exit 1
    fi
    
    if ! normalized_query=$(echo "$normalized_query" | perl -pe 's/--.*?$//g; s/\/\*.*?\*\///g; s/\s+/ /g;' 2>/dev/null); then
        echo "Error: Failed to process query comments and whitespace" >&2
        echo "The query contains malformed comments or special characters." >&2
        exit 1
    fi
    
    # Trim whitespace
    normalized_query=$(echo "$normalized_query" | xargs 2>/dev/null || echo "")
    
    if [[ -z "$normalized_query" ]]; then
        echo "Error: Query is empty or contains only whitespace/comments" >&2
        echo "Please provide a valid SQL query." >&2
        exit 1
    fi
    
    printf '%s' "$normalized_query"
}

check_read_only() {
    local query="$1"
    local normalized_query
    local query_length
    
    # Input length validation - prevent extremely long queries that could cause DoS
    query_length=${#query}
    if [[ $query_length -gt 1048576 ]]; then  # 1MB limit
        echo "Error: Query too long (maximum 1MB)" >&2
        echo "Please reduce the query size and try again." >&2
        exit 1
    fi
    
    # Remove null bytes and sanitize control characters, but allow common ones in string literals
    if printf '%s' "$query" | grep -qP '\x00'; then
        echo "Error: Query contains invalid null bytes" >&2
        echo "Please remove any binary data from the query." >&2
        exit 1
    fi
    
    # Normalize query with enhanced error handling
    normalized_query=$(normalize_query_content "$query") || {
        # The error message is already printed by normalize_query_content
        exit 1
    }

    # Check for dangerous patterns anywhere in the query
    local dangerous_patterns=(
        "insert "
        "update "
        "delete "
        "drop "
        "create "
        "alter "
        "truncate "
        "exec "
        "execute "
        "grant "
        "revoke "
        "commit "
        "rollback "
        "union "  # Will be validated with smart detection
        "load "   # LOAD DATA INFILE
        "copy "   # COPY command in PostgreSQL
        "backup " # BACKUP DATABASE
        "restore " # RESTORE DATABASE
    )

    for pattern in "${dangerous_patterns[@]}"; do
        if [[ "$normalized_query" =~ [[:space:]]$pattern ]]; then
            # Special handling for UNION - use smart detection
            if [[ "$pattern" == "union " ]]; then
                check_union_safety "$query"
            else
                echo "Error: Only read-only queries are allowed. Detected potentially dangerous pattern: $pattern" >&2
                echo "Please use only SELECT, WITH, SHOW, DESCRIBE, EXPLAIN, or PRAGMA statements." >&2
                exit 1
            fi
        fi
    done

    # Check for multiple statements (semicolon separation)
    if [[ "$normalized_query" == *";"* ]]; then
        echo "Error: Multiple SQL statements are not allowed" >&2
        echo "Each query must be a single SQL statement without semicolons." >&2
        exit 1
    fi

    # Query must start with a read-only operation
    if [[ ! "$normalized_query" =~ ^[[:space:]]*(select|with|show|describe|explain|pragma)[[:space:]] ]]; then
        echo "Error: Query must start with a read-only operation" >&2
        echo "Supported operations: SELECT, WITH, SHOW, DESCRIBE, EXPLAIN, PRAGMA" >&2
        echo "Example: SELECT * FROM users WHERE id = 1" >&2
        exit 1
    fi
}

detect_database_type() {
    local db_type="${DB_TYPE:-}"

    if [[ -n "$db_type" ]]; then
echo "$db_type"
        return 0
    fi

    # Try to detect from JDBC_URL if available
    if [[ -n "${JDBC_URL:-}" ]]; then
        case "$JDBC_URL" in
            *mysql*) echo "mysql"; return 0 ;;
            *postgresql*) echo "postgresql"; return 0 ;;
            *oracle*) echo "oracle"; return 0 ;;
            *sqlserver*) echo "sqlserver"; return 0 ;;
            *db2*) echo "db2"; return 0 ;;
            *as400*) echo "db2"; return 0 ;;
            *h2*) echo "h2"; return 0 ;;
            *sqlite*) echo "sqlite"; return 0 ;;
        esac
    fi

    # Try to detect from available drivers
    if [[ -d "$DRIVERS_DIR" ]]; then
        if ls "$DRIVERS_DIR"/*mysql* 1> /dev/null 2>&1; then echo "mysql"; return 0; fi
        if ls "$DRIVERS_DIR"/*postgresql* 1> /dev/null 2>&1; then echo "postgresql"; return 0; fi
        if ls "$DRIVERS_DIR"/*oracle* 1> /dev/null 2>&1; then echo "oracle"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlserver* 1> /dev/null 2>&1; then echo "sqlserver"; return 0; fi
        if ls "$DRIVERS_DIR"/*db2* 1> /dev/null 2>&1; then echo "db2"; return 0; fi
        if ls "$DRIVERS_DIR"/*h2* 1> /dev/null 2>&1; then echo "h2"; return 0; fi
        if ls "$DRIVERS_DIR"/*sqlite* 1> /dev/null 2>&1; then echo "sqlite"; return 0; fi
    fi

    return 1
}

# Validate and sanitize database connection and content
validate_database_security() {
    local db_type="$1"
    local db_connection_string="$2"
    
    debug "Validating database security for type: $db_type"
    
    # Validate database type against known safe types
    case "$db_type" in
        "sqlite"|"h2")
            # For file-based databases, additional validation
            if [[ -n "${db_connection_string:-}" ]]; then
                # Check for potential malicious file paths or injection attempts
                if [[ "$db_connection_string" =~ [\\\<\>\&\|\;\`] ]]; then
                    echo "Error: Database connection string contains invalid characters" >&2
                    echo "Please use a valid database file path or connection URL." >&2
                    exit 1
                fi
                
                # For SQLite, prevent access to system files
                if [[ "$db_type" == "sqlite" ]] && [[ "$db_connection_string" =~ ^/(etc|proc|sys|dev|boot|root|bin|sbin|lib|lib64)/ ]]; then
                    echo "Error: SQLite database path attempts to access system directories" >&2
                    echo "SQLite databases must be in user-accessible locations." >&2
                    exit 1
                fi
            fi
            ;;
        "mysql"|"postgresql"|"oracle"|"sqlserver"|"db2")
            # For server-based databases, validate connection string format
            if [[ -n "${db_connection_string:-}" ]]; then
                # Check for potential connection string injection
                if [[ "$db_connection_string" =~ (LOAD_FILE|SELECT.*INTO.*OUTFILE|EXEC|xp_|sp_|UNION|DROP|CREATE|ALTER) ]]; then
                    echo "Error: Database connection string contains suspicious patterns" >&2
                    echo "Please use a valid JDBC connection URL." >&2
                    exit 1
                fi
                
                # Validate JDBC URL format
                if ! [[ "$db_connection_string" =~ ^jdbc: ]]; then
                    echo "Error: Invalid JDBC URL format" >&2
                    echo "Connection string must start with 'jdbc:'" >&2
                    exit 1
                fi
                
                # Check for potential credential injection in URL
                local url_param_regex='[?&]([^&=]*)=([^&]*)'
                if [[ "$db_connection_string" =~ $url_param_regex ]]; then
                    local param_value="${BASH_REMATCH[2]}"
                    
                    # URL decode the values for validation
                    param_value=$(printf '%b' "${param_value//%/\\x}")
                    
                    # Check for dangerous values in connection parameters
                    if [[ "$param_value" =~ [\\\<\>\&\|\;\`] ]]; then
                        echo "Error: Database connection parameter contains invalid characters" >&2
                        echo "Connection parameters must not contain shell metacharacters." >&2
                        exit 1
                    fi
                fi
            fi
            ;;
    esac
}

# Enhanced database initialization with security checks
initialize_database_connection() {
    local db_type="$1"
    
    # Validate database security before attempting connection
    local jdbc_url_to_validate="${JDBC_URL:-}"
    if [[ -z "$jdbc_url_to_validate" ]]; then
        # If no JDBC URL, construct one for validation
        case "$db_type" in
            "sqlite")
                jdbc_url_to_validate="jdbc:sqlite:${DB_DATABASE:-}"
                ;;
            "h2")
                jdbc_url_to_validate="jdbc:h2:${DB_DATABASE:-}"
                ;;
            *)
                jdbc_url_to_validate="jdbc:${db_type}://${DB_HOST:-localhost}:${DB_PORT:-}/"
                if [[ -n "${DB_DATABASE:-}" ]]; then
                    jdbc_url_to_validate="${jdbc_url_to_validate}${DB_DATABASE}"
                fi
                ;;
        esac
    fi
    
    validate_database_security "$db_type" "$jdbc_url_to_validate"
    
    debug "Database security validation passed for $db_type"
}

# Enhanced JDBC parameter validation
validate_jdbc_params() {
    local db_type="$1"
    local db_host="$2"
    local db_port="$3"
    local db_database="$4"
    local db_user="$5"
    local db_password="$6"
    
    debug "Validating JDBC parameters for database type: $db_type"
    
    # For SQLite, parameters are optional
    if [[ "$db_type" == "sqlite" ]]; then
        if [[ -z "$db_database" ]]; then
            echo "Error: Database file path is required for SQLite" >&2
            exit 1
        fi
        # Validate SQLite database path
        if [[ "$db_database" =~ ^/(etc|proc|sys|dev|boot|root|bin|sbin|lib|lib64)/ ]]; then
            echo "Error: SQLite database path attempts to access system directories" >&2
            exit 1
        fi
        return 0
    fi
    
    # For other database types, validate required parameters
    if [[ -z "$db_host" ]]; then
        echo "Error: Database host is required for $db_type" >&2
        exit 1
    fi
    
    if [[ -n "$db_port" ]]; then
        # Validate port is numeric and in valid range
        if ! [[ "$db_port" =~ ^[0-9]+$ ]] || [[ $db_port -lt 1 ]] || [[ $db_port -gt 65535 ]]; then
            echo "Error: Invalid port number: $db_port" >&2
            echo "Port numbers must be between 1 and 65535" >&2
            exit 1
        fi
    fi
    
    if [[ -z "$db_database" ]]; then
        echo "Error: Database name is required for $db_type" >&2
        exit 1
    fi
    
    if [[ -z "$db_user" ]]; then
        echo "Error: Database user is required for $db_type" >&2
        exit 1
    fi
    
    if [[ -z "$db_password" ]]; then
        echo "Error: Database password is required for $db_type" >&2
        exit 1
    fi
    
    # Validate parameter values for injection attacks
    local params_to_check=("$db_host" "$db_database" "$db_user")
    local param_names=("host" "database" "user")
    
    for i in "${!params_to_check[@]}"; do
        local param_value="${params_to_check[$i]}"
        local param_name="${param_names[$i]}"
        
        # Check for potentially dangerous characters
        if [[ "$param_value" =~ [\\\<\>\&\|\;\`] ]]; then
            echo "Error: Invalid characters in $param_name: $param_value" >&2
            echo "Parameter values must not contain shell metacharacters" >&2
            exit 1
        fi
        
        # Check for SQL injection patterns
        if [[ "$param_value" =~ (UNION|SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|xp_|sp_) ]]; then
            echo "Error: Potentially dangerous pattern detected in $param_name: $param_value" >&2
            echo "Parameter values must not contain SQL keywords" >&2
            exit 1
        fi
    done
    
    debug "JDBC parameter validation passed for $db_type"
}

# Enhanced database configuration with validation
configure_database() {
    local db_type="$1"
    
    # Validate parameters before configuration
    validate_jdbc_params "$db_type" "${DB_HOST:-}" "${DB_PORT:-}" "${DB_DATABASE:-}" "${DB_USER:-}" "${DB_PASSWORD:-}"
    
    case "$db_type" in
        mysql)
            DB_PORT="${DB_PORT:-3306}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.mysql.cj.jdbc.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mysql-connector-java*.jar}"
            ;;
        postgresql)
            DB_PORT="${DB_PORT:-5432}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.postgresql.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_DATABASE}?connectTimeout=${timeout}000&socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-postgresql*.jar}"
            ;;
        oracle)
            DB_PORT="${DB_PORT:-1521}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-oracle.jdbc.OracleDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:oracle:thin:@${DB_HOST}:${DB_PORT}:${DB_DATABASE}?connectTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-ojdbc*.jar}"
            ;;
        sqlserver)
            DB_PORT="${DB_PORT:-1433}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.microsoft.sqlserver.jdbc.SQLServerDriver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:sqlserver://${DB_HOST}:${DB_PORT};databaseName=${DB_DATABASE};loginTimeout=${timeout};socketTimeout=${timeout}000"
            fi
            DRIVER_JAR="${DRIVER_JAR:-mssql-jdbc*.jar}"
            ;;
        db2)
            DB_PORT="${DB_PORT:-50000}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-com.ibm.db2.jcc.DB2Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                local timeout="${DB_TIMEOUT:-30}"
                JDBC_URL="jdbc:db2://${DB_HOST}:${DB_PORT}/${DB_DATABASE}:clientProgramName=${timeout};"
            fi
            DRIVER_JAR="${DRIVER_JAR:-db2jcc*.jar jt400*.jar}"
            ;;
        h2)
            DB_PORT="${DB_PORT:-9092}"
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.h2.Driver}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                JDBC_URL="jdbc:h2:tcp://${DB_HOST}:${DB_PORT}/${DB_DATABASE};loginTimeout=${timeout}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-h2*.jar}"
            ;;
        sqlite)
            JDBC_DRIVER_CLASS="${JDBC_DRIVER_CLASS:-org.sqlite.JDBC}"
            if [[ -z "${JDBC_URL:-}" ]]; then
                JDBC_URL="jdbc:sqlite:${DB_DATABASE}"
            fi
            DRIVER_JAR="${DRIVER_JAR:-sqlite-jdbc*.jar}"
            ;;
        *)
            echo "Error: Unsupported database type: $db_type" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
            ;;
    esac
    
    # Validate JDBC URL format
    if [[ -n "${JDBC_URL:-}" ]]; then
        # Basic JDBC URL validation
        if [[ ! "$JDBC_URL" =~ ^jdbc: ]]; then
            echo "Error: Invalid JDBC URL format: $JDBC_URL" >&2
            exit 1
        fi
        
        # Check for potentially dangerous JDBC URL patterns
        if [[ "$JDBC_URL" =~ [\$\`\\\<\>\&\|\;] ]]; then
            echo "Error: JDBC URL contains potentially dangerous characters" >&2
            exit 1
        fi
        
        # Validate that the URL matches the expected database type
        case "$db_type" in
            mysql)
                if [[ ! "$JDBC_URL" =~ ^jdbc:mysql: ]]; then
                    echo "Error: JDBC URL does not match MySQL database type" >&2
                    exit 1
                fi
                ;;
            postgresql)
                if [[ ! "$JDBC_URL" =~ ^jdbc:postgresql: ]]; then
                    echo "Error: JDBC URL does not match PostgreSQL database type" >&2
                    exit 1
                fi
                ;;
            oracle)
                if [[ ! "$JDBC_URL" =~ ^jdbc:oracle: ]]; then
                    echo "Error: JDBC URL does not match Oracle database type" >&2
                    exit 1
                fi
                ;;
            sqlserver)
                if [[ ! "$JDBC_URL" =~ ^jdbc:sqlserver: ]]; then
                    echo "Error: JDBC URL does not match SQL Server database type" >&2
                    exit 1
                fi
                ;;
             db2)
                 if [[ ! "$JDBC_URL" =~ ^jdbc:(db2|as400): ]]; then
                     echo "Error: JDBC URL does not match DB2/AS400 database type" >&2
                     exit 1
                 fi
                 ;;
            h2)
                if [[ ! "$JDBC_URL" =~ ^jdbc:h2: ]]; then
                    echo "Error: JDBC URL does not match H2 database type" >&2
                    exit 1
                fi
                ;;
            sqlite)
                if [[ ! "$JDBC_URL" =~ ^jdbc:sqlite: ]]; then
                    echo "Error: JDBC URL does not match SQLite database type" >&2
                    exit 1
                fi
                ;;
        esac
    fi
}

find_driver_jar() {
    local driver_pattern="$1"
    local jar_files=()

    # Search in drivers directory
    if [[ -d "$DRIVERS_DIR" ]]; then
        for pattern in $driver_pattern; do
            while IFS= read -r -d '' jar; do
                jar_files+=("$jar")
            done < <(find "$DRIVERS_DIR" -name "$pattern" -type f -print0 2>/dev/null)
        done
    fi

    # Search in script directory
    while IFS= read -r -d '' jar; do
        jar_files+=("$jar")
    done < <(find "$SCRIPT_DIR" -name "*.jar" -type f -print0 2>/dev/null)

    if [[ ${#jar_files[@]} -eq 0 ]]; then
        # Attempt to auto-download common drivers for missing cases (e.g., jt400 for AS/400/DB2)
        if echo "$driver_pattern" | grep -qi "jt400\|jt400*.jar\|db2jcc"; then
            echo "Warning: JDBC driver not found for pattern '$driver_pattern'. Attempting to download jt400 driver..." >&2
            if download_driver db2; then
                # Retry search after download
                jar_files=()
                if [[ -d "$DRIVERS_DIR" ]]; then
                    for pattern in $driver_pattern; do
                        while IFS= read -r -d '' jar; do
                            jar_files+=("$jar")
                        done < <(find "$DRIVERS_DIR" -name "$pattern" -type f -print0 2>/dev/null)
                    done
                fi
                while IFS= read -r -d '' jar; do
                    jar_files+=("$jar")
                done < <(find "$SCRIPT_DIR" -name "*.jar" -type f -print0 2>/dev/null)
            else
                echo "Warning: Automatic download of jt400 driver failed or was skipped." >&2
            fi
        fi
    fi

    if [[ ${#jar_files[@]} -eq 0 ]]; then
echo "Error: No JDBC driver found matching pattern: $driver_pattern" >&2
echo "Please place the appropriate JDBC driver JAR in $DRIVERS_DIR or $SCRIPT_DIR" >&2
        exit 1
    fi

    # Return the first match
    echo "${jar_files[0]}"
}

list_drivers() {
    echo "Available database drivers:"
    echo "=========================="

    local found_drivers=()

    if [[ -d "$DRIVERS_DIR" ]]; then
        while IFS= read -r -d '' jar; do
            local basename
            basename=$(basename "$jar")
            case "$basename" in
                *mysql*) found_drivers+=("MySQL: $basename") ;;
                *postgresql*) found_drivers+=("PostgreSQL: $basename") ;;
                *oracle*) found_drivers+=("Oracle: $basename") ;;
                *sqlserver*|*mssql*) found_drivers+=("SQL Server: $basename") ;;
                *db2*|*jt400*) found_drivers+=("DB2/AS400: $basename") ;;
                *h2*) found_drivers+=("H2: $basename") ;;
                *sqlite*) found_drivers+=("SQLite: $basename") ;;
                *) found_drivers+=("Unknown: $basename") ;;
            esac
        done < <(find "$DRIVERS_DIR" -name "*.jar" -type f -print0 2>/dev/null)
    fi

    if [[ ${#found_drivers[@]} -eq 0 ]]; then
echo "No JDBC drivers found in $DRIVERS_DIR"
echo "Download drivers and place them in the drivers directory:"
echo "- MySQL: https://dev.mysql.com/downloads/connector/j/"
echo "- PostgreSQL: https://jdbc.postgresql.org/download/"
echo "- Oracle: https://www.oracle.com/database/technologies/appdev/jdbc-downloads.html"
echo "- SQL Server: https://docs.microsoft.com/en-us/sql/connect/jdbc/download-microsoft-jdbc-driver-for-sql-server"
echo "- DB2: https://www.ibm.com/support/pages/node/6331129"
echo "- H2: https://www.h2database.com/html/download.html"
echo "- SQLite: https://github.com/xerial/sqlite-jdbc/releases"
    else
        printf '%s\n' "${found_drivers[@]}"
    fi
}

download_driver() {
    local type="$1"
    local url=""
    local filename=""
    case "$type" in
        mysql)
            url="https://repo1.maven.org/maven2/com/mysql/mysql-connector-j/8.0.33/mysql-connector-j-8.0.33.jar"
            filename="mysql-connector-j-8.0.33.jar"
            ;;
        postgresql)
            url="https://repo1.maven.org/maven2/org/postgresql/postgresql/42.6.0/postgresql-42.6.0.jar"
            filename="postgresql-42.6.0.jar"
            ;;
        h2)
            url="https://repo1.maven.org/maven2/com/h2database/h2/2.1.214/h2-2.1.214.jar"
            filename="h2-2.1.214.jar"
            ;;
        sqlite)
            url="https://repo1.maven.org/maven2/org/xerial/sqlite-jdbc/3.42.0.0/sqlite-jdbc-3.42.0.0.jar"
            filename="sqlite-jdbc-3.42.0.0.jar"
            ;;
        sqlserver)
            url="https://repo1.maven.org/maven2/com/microsoft/sqlserver/mssql-jdbc/12.4.1.jre11/mssql-jdbc-12.4.1.jre11.jar"
            filename="mssql-jdbc-12.4.1.jre11.jar"
            ;;
        db2)
            # jt400 isn't served via Maven central in a guaranteed stable path; try the OpenJTOpen release on Maven Central
            # Use a commonly available jt400 artifact
            url="https://repo1.maven.org/maven2/com/ibm/as400/jt400/10.5/jt400-10.5.jar"
            filename="jt400-10.5.jar"
            ;;
        *)
            echo "Error: Unsupported driver type: $type" >&2
            exit 1
            ;;
    esac
    mkdir -p "$DRIVERS_DIR"
    local dest="$DRIVERS_DIR/$filename"
    if [[ -f "$dest" ]]; then
        echo "Driver already exists: $dest" >&2
        return 0
    fi
    echo "Downloading $type driver from $url..." >&2
    if ! curl -L -o "$dest" "$url"; then
        echo "Error: Failed to download $url" >&2
        exit 1
    fi
    echo "Downloaded $type driver to $dest" >&2
}

test_connection() {
    local test_query="SELECT 1"
    execute_query "$test_query" "text" > /dev/null
    echo "Connection successful!" >&2
}

load_env() {
    local env_file_to_use="$ENV_FILE"
    
    # Use custom env file if specified
    if [[ -n "${CLI_ENV_FILE:-}" ]]; then
        env_file_to_use="$CLI_ENV_FILE"
    fi
    
    # Validate env file path first
    if ! normalize_fs_path "$env_file_to_use" >/dev/null 2>&1; then
        echo "Error: Invalid environment file path: $env_file_to_use" >&2
        exit 1
    fi
    
    if [[ ! -f "$env_file_to_use" ]]; then
        echo "Warning: Environment file not found at $env_file_to_use" >&2
        echo "You can specify connection details via command line options" >&2
    else
        # Secure environment file parsing
        set -a
        
        # Use a secure method to parse the environment file
        # Only allow valid environment variable names and values
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            # Skip lines that don't contain an equals sign
            [[ ! "$line" =~ ^[^=]+=[^=]*$ ]] && continue
            
            # Extract variable name and value
            local var_name="${line%%=*}"
            local var_value="${line#*=}"
            
            # Validate variable name (only allow alphanumeric and underscore)
            if ! [[ "$var_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                debug "Skipping invalid environment variable name: $var_name"
                continue
            fi
            
            # Validate variable value length
            if [[ ${#var_value} -gt 4096 ]]; then
                echo "Error: Environment variable value too long: $var_name" >&2
                exit 1
            fi
            
            # Remove surrounding quotes if present
            if [[ "$var_value" =~ ^[\"'](.*)[\"']$ ]]; then
                var_value="${BASH_REMATCH[1]}"
            fi
            
            # Set the environment variable safely
            export "$var_name=$var_value"
            
            # Debug logging (sanitized)
            case "$var_name" in
                *PASSWORD*|*SECRET*|*KEY*)
                    debug "Loaded environment variable: $var_name=******"
                    ;;
                *)
                    debug "Loaded environment variable: $var_name=$var_value"
                    ;;
            esac
        done < "$env_file_to_use"
        
        set +a
    fi

    # Override with command line arguments if provided (already validated)
    DB_HOST="${CLI_HOST:-${DB_HOST:-localhost}}"
    DB_PORT="${CLI_PORT:-${DB_PORT:-}}"
    DB_DATABASE="${CLI_DATABASE:-${DB_DATABASE:-}}"
    DB_USER="${CLI_USER:-${DB_USER:-}}"
    DB_PASSWORD="${CLI_PASSWORD:-${DB_PASSWORD:-}}"

    # Auto-detect or use specified database type (already validated)
    local db_type
    if [[ -n "${CLI_TYPE:-}" ]]; then
        db_type="$CLI_TYPE"
    else
        if ! db_type=$(detect_database_type); then
            echo "Error: Could not auto-detect database type" >&2
            echo "Please specify DB_TYPE in .env or use -t option" >&2
            echo "Supported types: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
            exit 1
        fi
    fi
    debug "Using database type: $db_type"
    
    # Initialize database connection with security validation
    initialize_database_connection "$db_type"
    
    # If using SQLite or H2, normalize DB_DATABASE path (unless in-memory or file: URI)
    if [[ -n "${DB_DATABASE:-}" && ("$db_type" == "sqlite" || ("$db_type" == "h2" && ("${DB_DATABASE}" == ~* || "${DB_DATABASE}" == /* || "${DB_DATABASE}" == */* || "${DB_DATABASE}" == ./*))) ]]; then
        case "${DB_DATABASE}" in
            ":memory:")
                debug "SQLite in-memory DB requested; skipping path normalization"
                ;;
            file:*)
                debug "SQLite file URI detected; skipping path normalization: ${DB_DATABASE}"
                ;;
            jdbc:sqlite:*)
                debug "SQLite JDBC URL detected; skipping path normalization: ${DB_DATABASE}"
                ;;
            *)
                # Normalize path and convert to absolute form if possible
                normalized_db=$(normalize_fs_path "${DB_DATABASE}") || { echo "Error: Invalid database path: ${DB_DATABASE}" >&2; exit 1; }
                # Convert to absolute if possible (use realpath -m if available)
                if [[ "${normalized_db}" != /* ]]; then
                    if command -v realpath >/dev/null 2>&1; then
                        normalized_db=$(realpath -m -- "${normalized_db}" 2>/dev/null || printf '%s' "${normalized_db}")
                    else
                        local db_dir db_base
                        db_dir=$(dirname -- "${normalized_db}" 2>/dev/null || printf '%s' "${normalized_db}")
                        db_base=$(basename -- "${normalized_db}" 2>/dev/null || printf '%s' "${normalized_db}")
                        if cd -- "${db_dir}" 2>/dev/null; then
                            normalized_db="$PWD/$db_base"
                        fi
                    fi
                fi
                DB_DATABASE="$normalized_db"
                debug "Normalized DB path: $DB_DATABASE"
                ;;
        esac
    fi
    
    # For H2, if we normalized above we still may want to log
    if [[ "$db_type" == "h2" && -n "${DB_DATABASE:-}" ]]; then
        debug "Final H2 DB identifier: $DB_DATABASE"
    fi
    configure_database "$db_type"

    # Find the appropriate driver JAR (already validated)
    JAR_FILE=$(find_driver_jar "$DRIVER_JAR")
    debug "Using driver: $(basename "$JAR_FILE")"

    # Validate required variables (already done for CLI, now for env vars)
    if [[ "$db_type" != "sqlite" ]]; then
        required_vars=("DB_HOST" "DB_USER" "DB_PASSWORD")
        for var in "${required_vars[@]}"; do
            if [[ -z "${!var:-}" ]]; then
                echo "Error: Required environment variable $var is not set" >&2
                exit 1
            fi
        done
    fi

    if [[ -z "${DB_DATABASE:-}" && "$db_type" != "sqlite" ]]; then
        echo "Error: Database name is required" >&2
        exit 1
    fi
}

execute_query() {
    local query="$1"
    local format="$2"

    check_read_only "$query"

    if [[ "$DAEMON_MODE" != "off" ]]; then
        local daemon_result
        if daemon_result=$(execute_query_daemon "$query" "$format" 2>/dev/null); then
            echo "$daemon_result"
            return 0
        fi
        debug "Daemon not available, falling back to single-query mode"
    fi

    local temp_dir
    temp_dir=$(mktemp -d)
    trap 'rm -rf "${temp_dir:-}"' EXIT

    local temp_java_file cache_key cached_class_file
    local precompiled_class
    local compilation_dir

    if precompiled_class=$(get_precompiled_class); then
        compilation_dir=$(dirname "$precompiled_class")
        debug "Using precompiled class in $compilation_dir"
    else
        # Initialize cache and check for valid cached compilation
        init_cache
        cleanup_old_cache
        cache_key=$(get_cache_key)

        if is_cache_valid "$cache_key"; then
            cached_class_file=$(load_from_cache "$cache_key")
            compilation_dir=$(dirname "$cached_class_file")
            debug "Using cached compiled class in $compilation_dir"
        else
            # Need to compile
            compilation_dir="$temp_dir"
            temp_java_file="$compilation_dir/QueryRunner.java"

cat > "$temp_java_file" << 'EOF'
import java.sql.*;
import java.util.*;
import java.util.regex.*;

public class QueryRunner {

    private static boolean isDebug() {
        String v = System.getenv("QUERY_RUNNER_DEBUG");
        return v != null && (v.equals("1") || v.equalsIgnoreCase("true"));
    }

    private static void debug(String msg) {
        if (isDebug()) System.err.println("DEBUG: " + msg);
    }

    private static String maskJdbcUrl(String url) {
        if (url == null) return null;
        // Mask password= param in JDBC URL if present
        try {
            return url.replaceAll("(?i)(password=)([^&;]+)", "$1******");
        } catch (Exception e) {
            return url;
        }
    }

    public static void main(String[] args) {
        String query = "";
        Scanner scanner = new Scanner(System.in);
        if (scanner.hasNextLine()) {
            query = scanner.useDelimiter("\\A").next();
        }
        String url = System.getenv("JDBC_URL");
        String driver = System.getenv("JDBC_DRIVER_CLASS");
        String user = System.getenv("DB_USER");
        String password = System.getenv("DB_PASSWORD");
        String format = System.getenv("OUTPUT_FORMAT");
        if (format == null) format = "text";
        debug("JDBC driver class: " + driver);
        debug("JDBC URL: " + maskJdbcUrl(url));
        debug("DB user: " + (user == null ? "(none)" : user));
        try {
            Class.forName(driver);
        } catch (ClassNotFoundException e) {
            System.err.println("Error: JDBC driver not found: " + e.getMessage());
            System.exit(1);
        }

        try (Connection conn = DriverManager.getConnection(url, user, password);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {

            ResultSetMetaData meta = rs.getMetaData();
            int columnCount = meta.getColumnCount();
            List<String> columnNames = new ArrayList<>();
            for (int i = 1; i <= columnCount; i++) {
                columnNames.add(meta.getColumnName(i));
            }

            switch (format) {
                case "pretty":
                    // For pretty format, load all rows to calculate widths
                    List<Map<String, Object>> rows = new ArrayList<>();
                    while (rs.next()) {
                        Map<String, Object> row = new HashMap<>();
                        for (int i = 1; i <= columnCount; i++) {
                            row.put(columnNames.get(i-1), rs.getObject(i));
                        }
                        rows.add(row);
                    }
                    outputPretty(columnNames, rows);
                    break;
                case "json":
                    outputJsonStream(columnNames, rs);
                    break;
                case "csv":
                    outputCsvStream(columnNames, rs);
                    break;
                case "text":
                default:
                    outputTextStream(columnNames, rs);
                    break;
            }
        } catch (SQLException e) {
            System.err.println("SQL Error: " + e.getMessage());
            System.err.println("SQL State: " + e.getSQLState());
            System.err.println("Error Code: " + e.getErrorCode());
            if (isDebug()) {
                e.printStackTrace(System.err);
            }
            System.exit(1);
        }
    }

    private static String escapeJson(String str) {
        if (str == null) {
            return null;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            switch (c) {
                case '\\':
                case '"':
                    sb.append('\\').append(c);
                    break;
                case '\b':
                    sb.append("\\b");
                    break;
                case '\t':
                    sb.append("\\t");
                    break;
                case '\n':
                    sb.append("\\n");
                    break;
                case '\f':
                    sb.append("\\f");
                    break;
                case '\r':
                    sb.append("\\r");
                    break;
                default:
                    if (c < ' ') {
                        String t = "000" + Integer.toHexString(c);
                        sb.append("\\u").append(t.substring(t.length() - 4));
                    } else {
                        sb.append(c);
                    }
            }
        }
        return sb.toString();
    }

    private static String repeatString(String str, int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {
            sb.append(str);
        }
        return sb.toString();
    }

    private static void outputJsonStream(List<String> columnNames, ResultSet rs) throws SQLException {
        System.out.print("[");
        boolean first = true;
        while (rs.next()) {
            if (!first) System.out.print(",");
            first = false;
            System.out.print("{");
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                System.out.print("\"" + escapeJson(columnNames.get(i)) + "\":");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("null");
                } else if (value instanceof Number || value instanceof Boolean) {
                    System.out.print(value.toString());
                } else {
                    System.out.print("\"" + escapeJson(value.toString()) + "\"");
                }
            }
            System.out.print("}");
        }
        System.out.println("]");
    }

    private static void outputCsvStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print(",");
            System.out.print("\"" + columnNames.get(i).replace("\"", "\"\"") + "\"");
        }
        System.out.println();
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print(",");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    System.out.print("");
                } else {
                    String strValue = value.toString();
                    System.out.print("\"" + strValue.replace("\"", "\"\"") + "\"");
                }
            }
            System.out.println();
        }
    }



    private static void outputTextStream(List<String> columnNames, ResultSet rs) throws SQLException {
        // Output header
        for (int i = 0; i < columnNames.size(); i++) {
            if (i > 0) System.out.print("\t");
            System.out.print(columnNames.get(i));
        }
        System.out.println();
        // Stream rows
        while (rs.next()) {
            for (int i = 0; i < columnNames.size(); i++) {
                if (i > 0) System.out.print("\t");
                Object value = rs.getObject(i + 1);
                System.out.print(value != null ? value.toString() : "NULL");
            }
            System.out.println();
        }
    }

    private static void outputPretty(List<String> columnNames, List<Map<String, Object>> rows) {
        int[] maxWidths = new int[columnNames.size()];
        for (int i = 0; i < columnNames.size(); i++) {
            maxWidths[i] = columnNames.get(i).length();
        }
        for (Map<String, Object> row : rows) {
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                maxWidths[i] = Math.max(maxWidths[i], strValue.length());
            }
        }
        String separator = "+";
        for (int width : maxWidths) {
            separator += repeatString("-", width + 2) + "+";
        }
        System.out.println(separator);
        System.out.print("|");
        for (int i = 0; i < columnNames.size(); i++) {
            System.out.print(" " + String.format("%-" + maxWidths[i] + "s", columnNames.get(i)) + " |");
        }
        System.out.println();
        System.out.println(separator);
        for (Map<String, Object> row : rows) {
            System.out.print("|");
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String strValue = value != null ? value.toString() : "NULL";
                System.out.print(" " + String.format("%-" + maxWidths[i] + "s", strValue) + " |");
            }
            System.out.println();
        }
        System.out.println(separator);
    }
}
EOF

    debug "Compiling temporary Java file: $temp_java_file"
    if ! javac_output=$("$JAVAC_BIN" "$temp_java_file" 2>&1); then
            echo "Error: Failed to compile Java code" >&2
            echo "Compilation error details:" >&2
            echo "$javac_output" >&2
            exit 1
        fi
        # Save to cache for future use
        save_to_cache "$cache_key" "$compilation_dir"
        debug "Compiled and saved class to cache at $compilation_dir"
        fi
    fi
    local classpath
    classpath=$(build_classpath "$JAR_FILE")
    export OUTPUT_FORMAT="$format" JDBC_URL JDBC_DRIVER_CLASS DB_USER DB_PASSWORD
    # Pass DEBUG to Java process as QUERY_RUNNER_DEBUG env var so the Java runner can also print debug info
    export QUERY_RUNNER_DEBUG="${DEBUG:-${QUERY_RUNNER_DEBUG:-0}}"
    echo -n "$query" | "$JAVA_BIN" --enable-native-access=ALL-UNNAMED -cp "$classpath:$compilation_dir" QueryRunner
    debug "Running java: $JAVA_BIN -cp $classpath:$compilation_dir QueryRunner"
}

# Check for Java availability
if ! check_java_availability; then
    download_standalone_jdk
fi

# Enhanced validate_cli_option with better error messages
validate_cli_option() {
    local option="$1"
    local value="$2"
    
    # Reject null bytes
    if printf '%s' "$value" | grep -qP '\x00'; then
        echo "Error: Invalid null bytes in $option value" >&2
        echo "Please remove any binary data from the $option parameter." >&2
        exit 1
    fi
    
    # Length validation for security (more reasonable limits)
    local value_length=${#value}
    case "$option" in
        "host"|"user"|"password")
            if [[ $value_length -gt 1024 ]]; then
                echo "Error: $option value too long (maximum 1024 characters)" >&2
                echo "Please reduce the $option length and try again." >&2
                exit 1
            fi
            # For host, allow common characters but reject dangerous ones
            if [[ "$option" == "host" ]]; then
                if [[ "$value" =~ [\\\<\>\&\|\;\`] ]]; then
                    echo "Error: Invalid characters in host name" >&2
                    echo "Host names should contain only letters, numbers, dots, and hyphens." >&2
                    exit 1
                fi
            fi
            ;;
        "database")
            if [[ $value_length -gt 2048 ]]; then
                echo "Error: Database value too long (maximum 2048 characters)" >&2
                echo "Please reduce the database name/path length and try again." >&2
                exit 1
            fi
            # Allow database names with reasonable characters
            if [[ "$value" =~ [\\\<\>\&\|\;\`] ]]; then
                echo "Error: Invalid characters in database name" >&2
                echo "Database names should not contain special shell characters." >&2
                exit 1
            fi
            ;;
        "port")
            if [[ $value_length -gt 5 ]]; then
                echo "Error: Port value too long" >&2
                echo "Port numbers should be 1-5 digits long." >&2
                exit 1
            fi
            # Validate port is numeric
            if ! [[ "$value" =~ ^[0-9]+$ ]] || [[ $value -lt 1 ]] || [[ $value -gt 65535 ]]; then
                echo "Error: Invalid port number: $value" >&2
                echo "Port numbers must be between 1 and 65535." >&2
                exit 1
            fi
            ;;
        "format")
            if [[ $value_length -gt 20 ]]; then
                echo "Error: Format value too long" >&2
                echo "Output format names should be shorter than 20 characters." >&2
                exit 1
            fi
            # Validate format is one of the allowed values
            if ! [[ "$value" =~ ^(text|csv|json|pretty)$ ]]; then
                echo "Error: Invalid format. Supported: text, csv, json, pretty" >&2
                echo "Please choose one of the supported output formats." >&2
                exit 1
            fi
            ;;
        "type")
            if [[ $value_length -gt 20 ]]; then
                echo "Error: Database type value too long" >&2
                echo "Database type names should be shorter than 20 characters." >&2
                exit 1
            fi
            # Validate database type
            if ! [[ "$value" =~ ^(mysql|postgresql|oracle|sqlserver|db2|h2|sqlite)$ ]]; then
                echo "Error: Invalid database type. Supported: mysql, postgresql, oracle, sqlserver, db2, h2, sqlite" >&2
                echo "Please choose one of the supported database types." >&2
                exit 1
            fi
            ;;
        "env-file"|"drivers-dir")
            # Validate file system paths
            if ! normalize_fs_path "$value" >/dev/null 2>&1; then
                echo "Error: Invalid path for $option: $value" >&2
                echo "Please provide a valid file system path." >&2
                echo "Paths should not contain control characters or binary data." >&2
                exit 1
            fi
            ;;
        "allow-union-tables")
            if [[ $value_length -gt 2048 ]]; then
                echo "Error: Union tables list too long" >&2
                echo "Please reduce the number of tables in the whitelist." >&2
                exit 1
            fi
            # Validate table names contain only safe characters (more permissive)
            if [[ "$value" =~ [\\\<\>\&\|\;\`] ]]; then
                echo "Error: Invalid characters in table names for allow-union-tables" >&2
                echo "Table names should not contain shell metacharacters." >&2
                exit 1
            fi
            ;;
    esac
    
    # Return the validated value
    printf '%s' "$value"
}

# Initialize CLI variables
CLI_HOST=""
CLI_PORT=""
CLI_DATABASE=""
CLI_USER=""
CLI_PASSWORD=""
CLI_TYPE=""
CLI_FORMAT="text"
CLI_ENV_FILE=""
ALLOW_UNION_TABLES=""
DOWNLOAD_DRIVER=""
DAEMON_ACTION=""
QUERY_FILE=""

# Enhanced command line parsing with validation
while [[ $# -gt 0 ]]; do
    case $1 in
        --)
            # End of options; treat the next argument as the query file (even if it starts with -)
            shift
            if [[ $# -ge 1 ]]; then
                QUERY_FILE="$1"
                shift
            fi
            break
            ;;
        -f|--format)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --format requires a value" >&2
                usage
            fi
            CLI_FORMAT=$(validate_cli_option "format" "$2")
            shift 2
            ;;
        -t|--type)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --type requires a value" >&2
                usage
            fi
            CLI_TYPE=$(validate_cli_option "type" "$2")
            shift 2
            ;;
        -h|--host)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --host requires a value" >&2
                usage
            fi
            CLI_HOST=$(validate_cli_option "host" "$2")
            shift 2
            ;;
        -p|--port)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --port requires a value" >&2
                usage
            fi
            CLI_PORT=$(validate_cli_option "port" "$2")
            shift 2
            ;;
        -d|--database)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --database requires a value" >&2
                usage
            fi
            CLI_DATABASE=$(validate_cli_option "database" "$2")
            shift 2
            ;;
        -u|--user)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --user requires a value" >&2
                usage
            fi
            CLI_USER=$(validate_cli_option "user" "$2")
            shift 2
            ;;
        -P|--password)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --password requires a value" >&2
                usage
            fi
            CLI_PASSWORD=$(validate_cli_option "password" "$2")
            shift 2
            ;;
        -e|--env-file)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --env-file requires a value" >&2
                usage
            fi
            CLI_ENV_FILE=$(validate_cli_option "env-file" "$2")
            shift 2
            ;;
        --drivers-dir)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --drivers-dir requires a value" >&2
                usage
            fi
            DRIVERS_DIR=$(validate_cli_option "drivers-dir" "$2")
            shift 2
            ;;
        --list-drivers)
            list_drivers
            exit 0
            ;;
        --test-connection)
            load_env
            test_connection
            exit 0
            ;;
        --download-driver)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --download-driver requires a value" >&2
                usage
            fi
            DOWNLOAD_DRIVER=$(validate_cli_option "type" "$2")
            shift 2
            ;;
--allow-union-tables)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --allow-union-tables requires a value" >&2
                usage
            fi
            ALLOW_UNION_TABLES=$(validate_cli_option "allow-union-tables" "$2")
            shift 2
            ;;
        --debug)
            CLI_DEBUG=1
            DEBUG=1
            shift
            ;;
        --daemon)
            DAEMON_MODE="auto"
            shift
            ;;
        --no-daemon)
            DAEMON_MODE="off"
            shift
            ;;
        --daemon-start)
            DAEMON_ACTION="start"
            shift
            ;;
        --daemon-stop)
            DAEMON_ACTION="stop"
            shift
            ;;
        --daemon-restart)
            DAEMON_ACTION="restart"
            shift
            ;;
        --daemon-status)
            DAEMON_ACTION="status"
            shift
            ;;
        --help)
            usage
            ;;
        -*)
            echo "Unknown option: $1" >&2
            usage
            ;;
        *)
            # Validate query file path
            if ! normalize_query_file_path "$1" >/dev/null 2>&1; then
                echo "Error: Invalid query file path: $1" >&2
                exit 1
            fi
            QUERY_FILE="$1"
            shift
            ;;
    esac
done

DAEMON_MODE="${DAEMON_MODE:-auto}"
DAEMON_SOCKET="$HOME/.query_runner/daemon.sock"
DAEMON_PORT_FILE="$HOME/.query_runner/daemon.port"
DAEMON_PID_FILE="$HOME/.query_runner/daemon.pid"
DAEMON_CLASS_DIR="$HOME/.query_runner/daemon_class"

is_daemon_running() {
    if [[ -S "$DAEMON_SOCKET" ]]; then
        if [[ -f "$DAEMON_PID_FILE" ]]; then
            local pid
            pid=$(cat "$DAEMON_PID_FILE" 2>/dev/null || echo "")
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                return 0
            fi
        fi
    fi
    if [[ -f "$DAEMON_PORT_FILE" ]] && [[ -f "$DAEMON_PID_FILE" ]]; then
        local pid port
        pid=$(cat "$DAEMON_PID_FILE" 2>/dev/null || echo "")
        port=$(cat "$DAEMON_PORT_FILE" 2>/dev/null || echo "")
        if [[ -n "$pid" ]] && [[ -n "$port" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
    fi
    return 1
}

get_daemon_endpoint() {
    if [[ -S "$DAEMON_SOCKET" ]]; then
        echo "UNIX:$DAEMON_SOCKET"
    elif [[ -f "$DAEMON_PORT_FILE" ]]; then
        port=$(cat "$DAEMON_PORT_FILE" 2>/dev/null || echo "")
        if [[ -n "$port" ]]; then
            echo "INET:localhost:$port"
        fi
    fi
}

get_daemon_pid() {
    if [[ -f "$DAEMON_PID_FILE" ]]; then
        cat "$DAEMON_PID_FILE" 2>/dev/null
    fi
}

start_daemon() {
    if is_daemon_running; then
        debug "Daemon already running (PID: $(get_daemon_pid))"
        return 0
    fi

    debug "Starting daemon..."

    mkdir -p "$HOME/.query_runner"

    local classpath
    classpath=$(build_classpath "$JAR_FILE")
    classpath="$classpath:$DAEMON_CLASS_DIR"

    if [[ ! -d "$DAEMON_CLASS_DIR" ]] || [[ -z "$(ls -A "$DAEMON_CLASS_DIR" 2>/dev/null)" ]]; then
        mkdir -p "$DAEMON_CLASS_DIR"
        local temp_dir
        temp_dir=$(mktemp -d)
        cat > "$temp_dir/QueryDaemon.java" << 'DAEMON_EOF'
import java.io.*;
import java.lang.reflect.*;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.sql.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.*;

public class QueryDaemon {
    private static final String SOCKET_PATH;
    private static final String PID_FILE;
    private static final long IDLE_TIMEOUT_MS = 300000L;
    private static final int POOL_MAX_SIZE = 10;
    private static final int POOL_MIN_IDLE = 2;
    private static final long POOL_TIMEOUT_MS = 30000L;

    static {
        String baseDir = System.getProperty("user.home") + "/.query_runner";
        SOCKET_PATH = baseDir + "/daemon.sock";
        PID_FILE = baseDir + "/daemon.pid";
    }

    private Object serverChannel;
    private final ExecutorService workerPool;
    private final ScheduledExecutorService scheduler;
    private final Properties config;
    private volatile boolean running = true;
    private volatile long lastActivityTime;
    private ConnectionPool pool;
    private ServerSocket listenerSocket;
    private boolean useUnixSocket;

    public QueryDaemon(Properties config) throws Exception {
        this.config = config;
        this.workerPool = Executors.newFixedThreadPool(POOL_MAX_SIZE);
        this.scheduler = Executors.newScheduledThreadPool(2);
        this.lastActivityTime = System.currentTimeMillis();

        java.nio.file.Path socketPath = Paths.get(SOCKET_PATH);
        Files.createDirectories(socketPath.getParent());

        if (Files.exists(socketPath)) {
            Files.delete(socketPath);
        }

        startListener();
        writePidFile();
        startIdleTimeout();
    }

    private void startListener() throws Exception {
        try {
            Class<?> unixServerSocketChannelClass = Class.forName("java.nio.channels.ServerSocketChannel");
            Method openMethod = unixServerSocketChannelClass.getMethod("open");
            Object serverChannelObj = openMethod.invoke(null);

            Class<?> unixDomainSocketAddressClass = Class.forName("jdk.net.UnixDomainSocketAddress");
            Method ofMethod = unixDomainSocketAddressClass.getMethod("of", String.class);
            Object addressObj = ofMethod.invoke(null, SOCKET_PATH);

            this.serverChannel = serverChannelObj;
            Method bindMethod = serverChannelObj.getClass().getMethod("bind", SocketAddress.class);
            bindMethod.invoke(serverChannelObj, addressObj);

            Method configureBlockingMethod = serverChannelObj.getClass().getMethod("configureBlocking", boolean.class);
            configureBlockingMethod.invoke(serverChannelObj, Boolean.TRUE);

            this.listenerSocket = (ServerSocket) serverChannelObj.getClass()
                .getMethod("socket").invoke(serverChannelObj);

            this.useUnixSocket = true;
            System.err.println("DEBUG: QueryDaemon started on " + SOCKET_PATH);
        } catch (Exception e) {
            System.err.println("DEBUG: Unix socket not available: " + e.getMessage());
            System.err.println("DEBUG: Falling back to INET socket");
            this.serverChannel = null;
            this.listenerSocket = new ServerSocket(0);
            this.useUnixSocket = false;
            System.err.println("DEBUG: QueryDaemon started on port " + listenerSocket.getLocalPort());
        }
    }

    private void writePidFile() throws IOException {
        String pid = Long.toString(ProcessHandle.current().pid());
        Files.writeString(Paths.get(PID_FILE), pid);
    }

    private void startIdleTimeout() {
        scheduler.scheduleAtFixedRate(() -> {
            if (running && System.currentTimeMillis() - lastActivityTime > IDLE_TIMEOUT_MS) {
                System.err.println("DEBUG: Idle timeout reached, shutting down daemon");
                shutdown();
            }
        }, 1000, 1000, TimeUnit.MILLISECONDS);
    }

    public void run() {
        while (running) {
            try {
                Socket clientSocket;
                if (useUnixSocket && serverChannel != null) {
                    Method acceptMethod = serverChannel.getClass().getMethod("accept");
                    Object clientChannel = acceptMethod.invoke(serverChannel);
                    if (clientChannel == null) continue;
                    Socket client = (Socket) clientChannel.getClass().getMethod("socket").invoke(clientChannel);
                    clientSocket = client;
                } else {
                    clientSocket = listenerSocket.accept();
                }

                if (!running) {
                    clientSocket.close();
                    break;
                }
                lastActivityTime = System.currentTimeMillis();
                workerPool.submit(() -> handleClient(clientSocket));

            } catch (Exception e) {
                if (running) {
                    System.err.println("DEBUG: Accept error: " + e.getMessage());
                }
                break;
            }
        }
    }

    private void handleClient(Socket clientSocket) {
        try {
            BufferedReader reader = new BufferedReader(
                new InputStreamReader(clientSocket.getInputStream(), StandardCharsets.UTF_8));
            PrintWriter writer = new PrintWriter(
                new OutputStreamWriter(clientSocket.getOutputStream(), StandardCharsets.UTF_8), true);

            String line = reader.readLine();
            if (line == null) return;

            String response = processRequest(line.trim());
            writer.println(response);

        } catch (Exception e) {
            System.err.println("DEBUG: Client handler error: " + e.getMessage());
        } finally {
            try { clientSocket.close(); } catch (IOException ignored) {}
        }
    }

    private String processRequest(String requestJson) {
        try {
            Map<String, Object> request = parseJson(requestJson);
            String type = (String) request.get("type");

            switch (type) {
                case "ping": return jsonResponse("ok", "pong", true);
                case "shutdown": return handleShutdown();
                case "status": return handleStatus();
                case "query": return handleQuery(request);
                default: return errorResponse("Unknown request type: " + type);
            }
        } catch (Exception e) {
            return errorResponse("Invalid request: " + e.getMessage());
        }
    }

    private String handleQuery(Map<String, Object> request) {
        String sql = (String) request.get("sql");
        String format = (String) request.getOrDefault("format", "text");

        if (sql == null || sql.trim().isEmpty()) {
            return errorResponse("SQL query is required");
        }

        if (sql.length() > 1048576) {
            return errorResponse("Query too long (maximum 1MB)");
        }

        sql = sql.replaceAll("\\u0000|\\p{Cntrl}", "");

        if (!isReadOnlyQuery(sql)) {
            return errorResponse("Only read-only queries are allowed");
        }

        try {
            if (pool == null) {
                pool = new ConnectionPool(config);
            }

            try (Connection conn = pool.getConnection();
                 Statement stmt = conn.createStatement();
                 ResultSet rs = stmt.executeQuery(sql)) {

                ResultSetMetaData meta = rs.getMetaData();
                int columnCount = meta.getColumnCount();
                List<String> columnNames = new ArrayList<>();
                for (int i = 1; i <= columnCount; i++) {
                    columnNames.add(meta.getColumnName(i));
                }

                StringBuilder result = new StringBuilder();
                result.append("{\"status\":\"ok\",");
                result.append("\"format\":\"").append(escapeJson(format)).append("\",");
                result.append("\"columns\":[");
                for (int i = 0; i < columnNames.size(); i++) {
                    if (i > 0) result.append(",");
                    result.append("\"").append(escapeJson(columnNames.get(i))).append("\"");
                }
                result.append("],");
                result.append("\"data\":");

                switch (format) {
                    case "json":
                        result.append(formatJson(rs, columnNames, columnCount));
                        break;
                    case "csv":
                        result.append(formatCsv(rs, columnNames, columnCount));
                        break;
                    case "pretty":
                        result.append(formatPretty(rs, columnNames, columnCount));
                        break;
                    default:
                        result.append(formatText(rs, columnNames, columnCount));
                }

                result.append("}");
                return result.toString();
            }
        } catch (SQLException e) {
            return errorResponse("SQL Error: " + sanitizeError(e.getMessage()));
        } catch (Exception e) {
            return errorResponse("Error: " + e.getMessage());
        }
    }

    private String formatText(ResultSet rs, List<String> columnNames, int columnCount) throws SQLException {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        boolean firstRow = true;
        while (rs.next()) {
            if (!firstRow) sb.append(",");
            firstRow = false;
            sb.append("[");
            for (int i = 0; i < columnCount; i++) {
                if (i > 0) sb.append(",");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    sb.append("null");
                } else {
                    sb.append("\"").append(escapeJson(value.toString())).append("\"");
                }
            }
            sb.append("]");
        }
        sb.append("]");
        return sb.toString();
    }

    private String formatJson(ResultSet rs, List<String> columnNames, int columnCount) throws SQLException {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        boolean firstRow = true;
        while (rs.next()) {
            if (!firstRow) sb.append(",");
            firstRow = false;
            sb.append("{");
            for (int i = 0; i < columnCount; i++) {
                if (i > 0) sb.append(",");
                sb.append("\"").append(escapeJson(columnNames.get(i))).append("\":");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    sb.append("null");
                } else if (value instanceof Number || value instanceof Boolean) {
                    sb.append(value.toString());
                } else {
                    sb.append("\"").append(escapeJson(value.toString())).append("\"");
                }
            }
            sb.append("}");
        }
        sb.append("]");
        return sb.toString();
    }

    private String formatCsv(ResultSet rs, List<String> columnNames, int columnCount) throws SQLException {
        StringBuilder sb = new StringBuilder();
        sb.append("[[");
        for (int i = 0; i < columnCount; i++) {
            if (i > 0) sb.append(",");
            sb.append("\"").append(escapeJson(columnNames.get(i))).append("\"");
        }
        sb.append("],");
        boolean firstRow = true;
        while (rs.next()) {
            if (!firstRow) sb.append(",");
            firstRow = false;
            sb.append("[");
            for (int i = 0; i < columnCount; i++) {
                if (i > 0) sb.append(",");
                Object value = rs.getObject(i + 1);
                if (value == null) {
                    sb.append("null");
                } else {
                    sb.append("\"").append(escapeJson(value.toString().replace("\"", "\"\""))).append("\"");
                }
            }
            sb.append("]");
        }
        sb.append("]");
        return sb.toString();
    }

    private String formatPretty(ResultSet rs, List<String> columnNames, int columnCount) throws SQLException {
        List<Map<String, Object>> rows = new ArrayList<>();
        while (rs.next()) {
            Map<String, Object> row = new LinkedHashMap<>();
            for (int i = 0; i < columnCount; i++) {
                row.put(columnNames.get(i), rs.getObject(i + 1));
            }
            rows.add(row);
        }

        StringBuilder sb = new StringBuilder();
        sb.append("{\"rows\":[");
        boolean firstRow = true;
        for (Map<String, Object> row : rows) {
            if (!firstRow) sb.append(",");
            firstRow = false;
            sb.append("{");
            boolean first = true;
            for (Map.Entry<String, Object> entry : row.entrySet()) {
                if (!first) sb.append(",");
                first = false;
                sb.append("\"").append(escapeJson(entry.getKey())).append("\":");
                Object value = entry.getValue();
                if (value == null) {
                    sb.append("null");
                } else {
                    sb.append("\"").append(escapeJson(value.toString())).append("\"");
                }
            }
            sb.append("}");
        }
        sb.append("],\"columnWidths\":[");
        int[] widths = calculateColumnWidths(columnNames, rows);
        for (int i = 0; i < widths.length; i++) {
            if (i > 0) sb.append(",");
            sb.append(widths[i]);
        }
        sb.append("]}");
        return sb.toString();
    }

    private int[] calculateColumnWidths(List<String> columnNames, List<Map<String, Object>> rows) {
        int[] widths = new int[columnNames.size()];
        for (int i = 0; i < columnNames.size(); i++) {
            widths[i] = columnNames.get(i).length();
        }
        for (Map<String, Object> row : rows) {
            for (int i = 0; i < columnNames.size(); i++) {
                Object value = row.get(columnNames.get(i));
                String str = value != null ? value.toString() : "NULL";
                widths[i] = Math.max(widths[i], str.length());
            }
        }
        return widths;
    }

    private String handleStatus() {
        long uptime = System.currentTimeMillis() - lastActivityTime;
        int activeConnections = pool != null ? pool.getActiveCount() : 0;
        int idleConnections = pool != null ? pool.getIdleCount() : 0;
        return String.format("{\"status\":\"ok\",\"uptime_ms\":%d,\"active_connections\":%d,\"idle_connections\":%d}",
            uptime, activeConnections, idleConnections);
    }

    private String handleShutdown() {
        running = false;
        shutdown();
        return "{\"status\":\"ok\",\"message\":\"Daemon shutdown complete\"}";
    }

    public void shutdown() {
        running = false;
        try {
            if (listenerSocket != null) listenerSocket.close();
            if (serverChannel != null) {
                Method closeMethod = serverChannel.getClass().getMethod("close");
                closeMethod.invoke(serverChannel);
            }
        } catch (Exception ignored) {}
        workerPool.shutdown();
        scheduler.shutdown();
        try {
            workerPool.awaitTermination(5, TimeUnit.SECONDS);
            scheduler.awaitTermination(5, TimeUnit.SECONDS);
        } catch (InterruptedException ignored) {}
        if (pool != null) pool.shutdown();
        try { Files.deleteIfExists(Paths.get(SOCKET_PATH)); } catch (IOException ignored) {}
        try { Files.deleteIfExists(Paths.get(PID_FILE)); } catch (IOException ignored) {}
    }

    private boolean isReadOnlyQuery(String sql) {
        String normalized = sql.toLowerCase().replaceAll("\\s+", " ").trim();
        if (!normalized.matches("^(select|with|show|describe|explain|pragma)\\s.*")) {
            return false;
        }
        if (normalized.contains("union") && !normalized.matches(".*union\\s+(all\\s+)?select.*")) {
            return false;
        }
        return !normalized.contains("insert ") && !normalized.contains("update ") &&
               !normalized.contains("delete ") && !normalized.contains("drop ") &&
               !normalized.contains("create ") && !normalized.contains("alter ") &&
               !normalized.contains("truncate ") && !normalized.contains("exec ") &&
               !normalized.contains("execute ") && !normalized.contains("grant ") &&
               !normalized.contains("revoke ") && !normalized.contains("commit ") &&
               !normalized.contains("rollback ");
    }

    private Map<String, Object> parseJson(String json) {
        Map<String, Object> result = new LinkedHashMap<>();
        String trimmed = json.trim();
        if (!trimmed.startsWith("{") || !trimmed.endsWith("}")) {
            throw new IllegalArgumentException("Invalid JSON object");
        }
        String content = trimmed.substring(1, trimmed.length() - 1);
        int depth = 0;
        int start = 0;
        boolean inString = false;
        boolean escaped = false;

        for (int i = 0; i <= content.length(); i++) {
            char c = i < content.length() ? content.charAt(i) : ',';
            if (escaped) {
                escaped = false;
                continue;
            }
            if (c == '\\') {
                escaped = true;
                continue;
            }
            if (c == '"') {
                inString = !inString;
                continue;
            }
            if (inString) continue;

            if (c == '{' || c == '[') depth++;
            if (c == '}' || c == ']') depth--;
            if (depth == 0 && (c == ',' || i == content.length())) {
                String pair = content.substring(start, i).trim();
                start = i + 1;
                if (pair.isEmpty()) continue;
                int colonPos = findColon(pair);
                if (colonPos == -1) continue;
                String key = pair.substring(0, colonPos).trim();
                String value = pair.substring(colonPos + 1).trim();
                result.put(unquote(key), parseValue(value));
            }
        }
        return result;
    }

    private int findColon(String s) {
        boolean inString = false;
        boolean escaped = false;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (escaped) {
                escaped = false;
                continue;
            }
            if (c == '\\') {
                escaped = true;
                continue;
            }
            if (c == '"') {
                inString = !inString;
                continue;
            }
            if (!inString && c == ':') return i;
        }
        return -1;
    }

    private Object parseValue(String value) {
        if (value.startsWith("\"")) {
            return unquote(value);
        }
        if (value.equals("true")) return Boolean.TRUE;
        if (value.equals("false")) return Boolean.FALSE;
        if (value.equals("null")) return null;
        try {
            if (value.contains(".")) {
                return Double.parseDouble(value);
            }
            return Long.parseLong(value);
        } catch (NumberFormatException e) {
            return value;
        }
    }

    private String unquote(String s) {
        if (s.startsWith("\"") && s.endsWith("\"") && s.length() >= 2) {
            return s.substring(1, s.length() - 1).replace("\\\"", "\"").replace("\\\\", "\\");
        }
        return s;
    }

    private String escapeJson(String str) {
        if (str == null) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            switch (c) {
                case '"': sb.append("\\\""); break;
                case '\\': sb.append("\\\\"); break;
                case '\n': sb.append("\\n"); break;
                case '\r': sb.append("\\r"); break;
                case '\t': sb.append("\\t"); break;
                case '\b': sb.append("\\b"); break;
                case '\f': sb.append("\\f"); break;
                default:
                    if (c < ' ' || c > 127) {
                        sb.append(String.format("\\u%04x", (int) c));
                    } else {
                        sb.append(c);
                    }
            }
        }
        return sb.toString();
    }

    private String sanitizeError(String msg) {
        if (msg == null) return "Unknown error";
        return msg.replaceAll("(?i)(password|passwd|pwd)\\s*[:=]\\s*[^\\s,;]+", "$1=******")
                  .replaceAll("(?i)(user|username|uid)\\s*[:=]\\s*[^\\s,;]+", "$1=******")
                  .replaceAll("(?i)(host|server)\\s*[:=]\\s*[^\\s,;]+", "$1=******");
    }

    private String jsonResponse(String status, String key, Object value) {
        return String.format("{\"status\":\"%s\",\"%s\":%s}", status, key,
            value instanceof String ? "\"" + escapeJson((String) value) + "\"" : value);
    }

    private String errorResponse(String message) {
        return String.format("{\"status\":\"error\",\"message\":\"%s\"}", escapeJson(message));
    }

    static class ConnectionPool {
        private final List<Connection> connections = new CopyOnWriteArrayList<>();
        private final Properties config;
        private int activeCount = 0;
        private int idleCount = 0;

        ConnectionPool(Properties config) {
            this.config = config;
            initializePool();
        }

        private void initializePool() {
            for (int i = 0; i < POOL_MIN_IDLE; i++) {
                Connection conn = createConnection();
                if (conn != null) {
                    connections.add(conn);
                    idleCount++;
                }
            }
        }

        Connection getConnection() throws SQLException {
            long start = System.currentTimeMillis();
            while (System.currentTimeMillis() - start < POOL_TIMEOUT_MS) {
                for (Connection conn : connections) {
                    if (isValid(conn)) {
                        connections.remove(conn);
                        activeCount++;
                        idleCount--;
                        return conn;
                    }
                    connections.remove(conn);
                }
                if (connections.size() < POOL_MAX_SIZE) {
                    Connection newConn = createConnection();
                    if (newConn != null) {
                        connections.add(newConn);
                        idleCount++;
                    }
                }
                if (connections.isEmpty()) {
                    Connection conn = createConnection();
                    if (conn != null) {
                        connections.add(conn);
                        idleCount++;
                    }
                }
                if (!connections.isEmpty()) {
                    Connection conn = connections.remove(0);
                    activeCount++;
                    idleCount--;
                    return conn;
                }
                try { Thread.sleep(10); } catch (InterruptedException ignored) {}
            }
            throw new SQLException("Connection timeout");
        }

        void returnConnection(Connection conn) {
            if (conn != null && isValid(conn)) {
                connections.add(conn);
                activeCount--;
                idleCount++;
            }
        }

        void shutdown() {
            for (Connection conn : connections) {
                try { conn.close(); } catch (SQLException ignored) {}
            }
            connections.clear();
            idleCount = 0;
            activeCount = 0;
        }

        int getActiveCount() { return activeCount; }
        int getIdleCount() { return idleCount; }

        private Connection createConnection() {
            try {
                Class.forName(config.getProperty("JDBC_DRIVER_CLASS"));
                return DriverManager.getConnection(
                    config.getProperty("JDBC_URL"),
                    config.getProperty("DB_USER"),
                    config.getProperty("DB_PASSWORD")
                );
            } catch (Exception e) {
                System.err.println("DEBUG: Failed to create connection: " + e.getMessage());
                return null;
            }
        }

        private boolean isValid(Connection conn) {
            try {
                return conn != null && conn.isValid(5);
            } catch (SQLException e) {
                return false;
            }
        }
    }

    public static void main(String[] args) {
        Properties config = new Properties();
        config.setProperty("JDBC_URL", System.getenv("JDBC_URL"));
        config.setProperty("JDBC_DRIVER_CLASS", System.getenv("JDBC_DRIVER_CLASS"));
        config.setProperty("DB_USER", System.getenv("DB_USER"));
        config.setProperty("DB_PASSWORD", System.getenv("DB_PASSWORD"));

        try {
            QueryDaemon daemon = new QueryDaemon(config);
            daemon.run();
        } catch (Exception e) {
            System.err.println("DEBUG: Daemon failed: " + e.getMessage());
            System.exit(1);
        }
    }
}
DAEMON_EOF
        if ! javac_output=$("$JAVAC_BIN" -d "$DAEMON_CLASS_DIR" "$temp_dir/QueryDaemon.java" 2>&1); then
            echo "Error: Failed to compile QueryDaemon: $javac_output" >&2
            rm -rf "$temp_dir"
            return 1
        fi
        rm -rf "$temp_dir"
    fi

    export JDBC_URL JDBC_DRIVER_CLASS DB_USER DB_PASSWORD QUERY_RUNNER_DEBUG
    nohup "$JAVA_BIN" --enable-native-access=ALL-UNNAMED -cp "$classpath" QueryDaemon > "$HOME/.query_runner/daemon.log" 2>&1 &
    local daemon_pid=$!
    echo "$daemon_pid" > "$DAEMON_PID_FILE"

    sleep 1

    if kill -0 "$daemon_pid" 2>/dev/null; then
        if [[ -S "$DAEMON_SOCKET" ]]; then
            rm -f "$DAEMON_PORT_FILE" 2>/dev/null || true
            debug "Daemon started with PID: $daemon_pid (Unix socket)"
        else
            local port
            port=$(grep -oP 'started on port \K\d+' "$HOME/.query_runner/daemon.log" 2>/dev/null | tail -1 || echo "")
            if [[ -n "$port" ]]; then
                echo "$port" > "$DAEMON_PORT_FILE"
                debug "Daemon started with PID: $daemon_pid (INET port $port)"
            else
                debug "Daemon started with PID: $daemon_pid"
            fi
        fi
        return 0
    else
        echo "Error: Failed to start daemon" >&2
        rm -f "$DAEMON_PID_FILE" "$DAEMON_PORT_FILE"
        if [[ -f "$HOME/.query_runner/daemon.log" ]]; then
            cat "$HOME/.query_runner/daemon.log" >&2
        fi
        return 1
    fi
}

stop_daemon() {
    if ! is_daemon_running; then
        echo "Daemon is not running"
        rm -f "$DAEMON_PID_FILE" "$DAEMON_SOCKET" "$DAEMON_PORT_FILE" 2>/dev/null || true
        return 0
    fi

    local pid
    pid=$(get_daemon_pid)
    debug "Stopping daemon (PID: $pid)..."

    if [[ -S "$DAEMON_SOCKET" ]]; then
        echo '{"type":"shutdown"}' | timeout 5 socat - UNIX-CONNECT:"$DAEMON_SOCKET" - 2>/dev/null || true
    elif [[ -f "$DAEMON_PORT_FILE" ]]; then
        local port
        port=$(cat "$DAEMON_PORT_FILE" 2>/dev/null || echo "")
        if [[ -n "$port" ]]; then
            echo '{"type":"shutdown"}' | timeout 5 nc localhost "$port" 2>/dev/null || true
        fi
    fi

    sleep 0.5
    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid" 2>/dev/null || true
        sleep 0.5
    fi

    rm -f "$DAEMON_PID_FILE" "$DAEMON_SOCKET" "$DAEMON_PORT_FILE" 2>/dev/null || true
    echo "Daemon stopped"
}

restart_daemon() {
    stop_daemon
    sleep 1
    start_daemon
}

daemon_status() {
    if is_daemon_running; then
        local pid endpoint
        pid=$(get_daemon_pid)
        endpoint=$(get_daemon_endpoint)
        echo "Daemon is running (PID: $pid, $endpoint)"
        local response
        if [[ -S "$DAEMON_SOCKET" ]]; then
            response=$(echo '{"type":"status"}' | timeout 2 socat UNIX-CONNECT:"$DAEMON_SOCKET" - 2>/dev/null || echo '{"status":"error"}')
        elif [[ -f "$DAEMON_PORT_FILE" ]]; then
            local port
            port=$(cat "$DAEMON_PORT_FILE" 2>/dev/null || echo "")
            if [[ -n "$port" ]]; then
                response=$(echo '{"type":"status"}' | timeout 2 nc localhost "$port" 2>/dev/null || echo '{"status":"error"}')
            fi
        fi
        echo "Status: $response"
        return 0
    else
        echo "Daemon is not running"
        return 1
    fi
}

execute_query_daemon() {
    local query="$1"
    local format="$2"

    if ! is_daemon_running; then
        if [[ "$DAEMON_MODE" == "off" ]]; then
            return 1
        fi
        start_daemon || return 1
    fi

    local request="{\"type\":\"query\",\"sql\":$(printf '%s' "$query" | jq -Rs .),\"format\":\"$format\"}"
    local response

    if [[ -S "$DAEMON_SOCKET" ]]; then
        response=$(echo "$request" | timeout 30 socat UNIX-CONNECT:"$DAEMON_SOCKET" - 2>/dev/null)
    elif [[ -f "$DAEMON_PORT_FILE" ]]; then
        local port
        port=$(cat "$DAEMON_PORT_FILE" 2>/dev/null || echo "")
        if [[ -n "$port" ]]; then
            response=$(echo "$request" | timeout 30 nc localhost "$port" 2>/dev/null)
        fi
    fi

    if [[ -z "$response" ]]; then
        echo "Error: No response from daemon" >&2
        return 1
    fi

    local status
    status=$(echo "$response" | jq -r '.status' 2>/dev/null || echo "error")

    if [[ "$status" == "ok" ]]; then
        local output_format
        output_format=$(echo "$response" | jq -r '.format' 2>/dev/null || echo "text")
        local columns
        columns=$(echo "$response" | jq -c '.columns' 2>/dev/null || echo "[]")
        local data
        data=$(echo "$response" | jq '.data' 2>/dev/null || echo "[]")

        format_daemon_output "$output_format" "$columns" "$data"
        return 0
    else
        local error_msg
        error_msg=$(echo "$response" | jq -r '.message' 2>/dev/null || echo "Unknown error")
        echo "Error: $error_msg" >&2
        return 1
    fi
}

format_daemon_output() {
    local format="$1"
    local columns="$2"
    local data="$3"

    case "$format" in
        text)
            local col_names
            col_names=$(echo "$columns" | jq -r '.[]' 2>/dev/null | tr '\n' '\t')
            if [[ -n "$col_names" ]]; then
                echo "$col_names"
            fi
            echo "$data" | jq -r '.[] | .[]' 2>/dev/null | paste - - | tr '\t' '\n' | while IFS= read -r row; do
                echo "$row"
            done
            ;;
        json)
            echo "$data"
            ;;
        csv)
            local headers
            headers=$(echo "$columns" | jq -r '.[]' 2>/dev/null | tr '\n' ',')
            if [[ -n "$headers" ]]; then
                echo "$headers"
            fi
            echo "$data" | jq -r '.[] | .[]' 2>/dev/null | paste - - | tr '\t' ',' | while IFS= read -r row; do
                echo "$row"
            done
            ;;
        pretty)
            echo "$data" | jq '.'
            ;;
        *)
            echo "$data"
            ;;
    esac
}

if [[ -n "$DOWNLOAD_DRIVER" ]]; then
    download_driver "$DOWNLOAD_DRIVER"
    exit 0
fi

if [[ -n "$DAEMON_ACTION" ]]; then
    case "$DAEMON_ACTION" in
        start)
            load_env
            start_daemon
            exit $?
            ;;
        stop)
            stop_daemon
            exit $?
            ;;
        restart)
            restart_daemon
            exit $?
            ;;
        status)
            daemon_status
            exit $?
            ;;
        *)
            echo "Unknown daemon action: $DAEMON_ACTION" >&2
            exit 1
            ;;
    esac
fi

# Set DEBUG based on CLI flags or environment variable
DEBUG="${CLI_VERBOSE:-${CLI_DEBUG:-${QUERY_RUNNER_DEBUG:-0}}}"
if [[ "$DEBUG" != "0" && "$DEBUG" != "false" ]]; then
    debug "Debug mode enabled (DEBUG=$DEBUG)."
fi

# Load environment
load_env

# Get query
if [[ -n "$QUERY_FILE" ]]; then
    # Normalize/harden path
    normalized_query_file=$(normalize_query_file_path "$QUERY_FILE") || {
        echo "Error: Invalid or unsafe query file path: $QUERY_FILE" >&2
        echo "Please check the file path and ensure it contains only valid characters." >&2
        exit 1
    }
    
    if [[ "$normalized_query_file" == "-" ]]; then
        # Read from stdin if explicit - provided
        query=$(cat -) || {
            echo "Error: Failed to read from stdin" >&2
            exit 1
        }
    else
        if [[ ! -f "$normalized_query_file" ]]; then
            echo "Error: Query file not found: $normalized_query_file" >&2
            echo "Please check the file path and ensure the file exists." >&2
            exit 1
        fi
        
        if [[ ! -r "$normalized_query_file" ]]; then
            echo "Error: Cannot read query file: $normalized_query_file" >&2
            echo "Please check file permissions." >&2
            exit 1
        fi
        
        # Read file into variable, stripping a UTF-8 BOM if present
        # Some editors add a BOM (EF BB BF) which breaks normalization; remove it here.
        if head -c 3 "$normalized_query_file" 2>/dev/null | od -An -t x1 | tr -d ' \t\n' | grep -qi '^efbbbf$'; then
            query=$(sed -e '1s/^\xEF\xBB\xBF//' -- "$normalized_query_file") || {
                echo "Error: Failed to read query file: $normalized_query_file" >&2
                echo "Please check file permissions and ensure the file is not corrupted." >&2
                exit 1
            }
        else
            query=$(cat -- "$normalized_query_file") || {
                echo "Error: Failed to read query file: $normalized_query_file" >&2
                echo "Please check file permissions and ensure the file is not corrupted." >&2
                exit 1
            }
        fi
    fi
else
    # Read from stdin with proper error handling
    if ! query=$(cat -) 2>/dev/null; then
        if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
            echo "Error: Failed to read query from stdin" >&2
            echo "Please ensure input is properly formatted and not truncated." >&2
            exit 1
        fi
        query=""
    fi
fi

# Validate that we have a query
if [[ -z "$query" ]]; then
    echo "Error: No query provided" >&2
    echo "Usage: $0 [OPTIONS] [QUERY_FILE]" >&2
    echo "   or: echo 'SELECT * FROM table' | $0 [OPTIONS]" >&2
    exit 1
fi

# Execute
execute_query "$query" "$CLI_FORMAT"
